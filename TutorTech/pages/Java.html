<!DOCTYPE html>
<html>

<body>

    <head>
        <title>Interview Questions - Java for Automation Testing role</title>
        <style>
            :root {
                --themeColor: #4285F4;
                --themeColorLight: #4285F4;
                --white: #faf0e6;
            }

            #postcontenttitle {
                padding: 15px;
                font-size: 1rem;
                font-weight: bold;
                line-height: 1.25rem;
                font-family: sans-serif;
                background-color: var(--themeColor) !important;
                color: #fff;
                border: 2px solid var(--themeColor);
                border-top-left-radius: 1rem;
                border-bottom-left-radius: 1rem;
            }

            #postcontent {
                margin: auto;
                background: rgb(255, 255, 255);
            }

            #postcontent a {
                color: blue !important;
            }

            #postcontent a:hover {
                color: lightblue !important;
            }

            .h-scrollable {
                overflow: auto;
                white-space: nowrap;
                padding: 5%;
                border: 1px solid #ddd;
                font-size: 0.8rem;
            }

            .code {
                padding: 15px;
                font-size: 0.75rem;
                font-family: monospace;
                color: #232323;
                background-color: #fff;
                border: 1px solid var(--themeColorLight);
                line-height: 1rem;
                min-height: 100px;
            }

            .viewAllLink {
                float: center;
                text-align: center;
                margin: 20px;
                padding: 15px;
                font-size: 1rem;
                font-weight: bold;
                line-height: 1.25rem;
                font-family: sans-serif;
                color: var(--themeColor) !important;
                border-radius: 1rem;
                width: 200px;
            }

            .viewAllLink a {
                text-decoration: none;
                color: var(--themeColor) !important;
            }

            .center {
                margin: auto;
            }

            button {
                position: relative;
                background-color: var(--themeColor) !important;
                color: #FFFFFF;
                padding: 10px;
                width: 200px;
                text-align: center;
                text-decoration: none;
                overflow: hidden;
                cursor: pointer;
                border-radius: 1rem;
                font-weight: bold;
                border: 2px solid var(--themeColor) !important;
            }

            button:after {
                content: "";
                background: var(--themeColor) !important;
                display: block;
                position: absolute;
                padding-top: 300%;
                padding-left: 350%;
                margin-left: -20px !important;
                margin-top: -120%;
                opacity: 0;
                transition: all 0.8s;
                border: 2px solid var(--themeColor) !important;
            }

            button:active:after {
                padding: 0;
                margin: 0;
                opacity: 1;
                transition: 0s
            }

            button:hover {
                background-color: #FFFFFF !important;
                color: var(--themeColor) !important;
                border: 2px solid var(--themeColor) !important;
            }

            pre {
                background-color: var(--themeColorLight) !important;
                font-weight: bold;
                padding: 5px;
            }

            /* Global styles */
            body {
                font-family: Arial, sans-serif;
                margin: 0;
                padding: 0;
                background-color: #f2f2f2;
            }

            .container {
                max-width: 90%;
                margin: 0 auto;
                padding: 20px;
            }

            /* Style for the question section */
            .question {
                background-color: #f9f9f9;
                padding: 10px;
                font-weight: bold;
                font-size: 0.75rem;
                font-family: sans-serif;
                cursor: pointer;
                border-bottom: 2px solid #ddd;
                line-height: 1.5rem;
            }


            .question:hover {
                background-color: #555;
                color: #fff;
            }

            /* Style for the answer section */
            .answer {
                padding: 10px;
                font-size: 14px;
                line-height: 1.5;
                display: none;
            }

            /* Style for the active question section */
            .question.active {
                background-color: var(--themeColor) !important;
                color: #fff;
            }

            .arrow-down {
                display: inline-block;
                margin-right: 10px;
                width: 0;
                height: 0;
                border-top: 10px solid #555;
                border-right: 6px solid transparent;
                border-left: 6px solid transparent;
                transform: rotate(0deg);
                transition: transform 0.2s;
            }

            .question.active .arrow-down {
                transform: rotate(180deg);
                border-top: 10px solid #fff;
            }

            span.arrow-down {
                float: right;
            }
        </style>
    </head>

    <br><br>

    <div class="container">
        <div id="postcontenttitle" style="text-align: center;">
            Interview Questions - Java for Automation Testing role
        </div>
    </div>

    
    <br>

    <div style="width: 100%;">
        <div class="viewAllLink center">
            <button
                onclick="window.location.href='https://way2qae.blogspot.com/2022/07/interview-questions-related-to-java.html';">View
                All Questions</button>
        </div>
    </div>

    <div class="container" id="qa-section">

    </div>


    <script type="text/javascript">
        const quesAnsArray = [
            {
                "ques": "Which type is used in collections to add all the primitive data types?",
                "ans": "<div><p>In Java, the <code>Collections</code> framework provides a set of interfaces and classes to represent and manipulate collections of objects. These collections can contain objects of any class, including the primitive data types such as <code>int</code>, <code>float</code>, <code>double</code>, <code>char</code>, and <code>boolean</code>. However, since primitive types are not objects, they cannot be directly added to collections. Instead, we use their corresponding wrapper classes to add them to collections.</p><p>The wrapper classes for primitive types are as follows:</p><ul><li><code>Integer</code> for <code>int</code></li><li><code>Float</code> for <code>float</code></li><li><code>Double</code> for <code>double</code></li><li><code>Character</code> for <code>char</code></li><li><code>Boolean</code> for <code>boolean</code></li></ul><p>To add primitive types to collections, we create instances of the corresponding wrapper classes and add them to the collection. For example, to add a set of integers to a <code>List</code> collection, we can use the following code:</p><pre><div><div><code>List&lt;Integer&gt; list = <span>new</span> ArrayList&lt;Integer&gt;();<br>list.<span>add</span>(<span>1</span>);<br>list.<span>add</span>(<span>2</span>);<br>list.<span>add</span>(<span>3</span>);<br></code></div></div></pre><p>Here, we create a new <code>ArrayList</code> object to hold the integers, and then add the integer values 1, 2, and 3 to the list using the <code>add()</code> method. Note that the integer values are not added directly, but instead we create <code>Integer</code> objects to represent them.</p><p>We can also use the <code>addAll()</code> method to add all the elements of an array or another collection to a collection. For example, to add an array of integers to a <code>Set</code> collection, we can use the following code:</p><pre><div><div><code><span>Set</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>set</span> <span>=</span> <span>new</span> HashSet<span>&lt;</span><span>Integer</span><span>&gt;</span>();<br><span>int</span>[] <span>array</span> <span>=</span> {<span>1</span>, <span>2</span>, <span>3</span>};<br>set.addAll(Arrays.asList(Arrays.stream(<span>array</span>).boxed().toArray(<span>Integer</span>[]::<span>new</span>)));<br></code></div></div></pre><p>Here, we create a new <code>HashSet</code> object to hold the integers, and then create an array of integers with values 1, 2, and 3. We then convert the array to a <code>List</code> using the <code>Arrays.asList()</code> method, and then convert the <code>List</code> to an array of <code>Integer</code> objects using the <code>boxed()</code> and <code>toArray()</code> methods. Finally, we add all the elements of the array to the <code>Set</code> using the <code>addAll()</code> method.</p><p>In summary, to add primitive data types to collections in Java, we use their corresponding wrapper classes and then add them to the collection using the <code>add()</code> or <code>addAll()</code> methods.</p></div>"
            },
            {
                "ques": "why main() is declared as static?",
                "ans": "<div><p>In Java, the <code>main()</code> method is the entry point of any Java program. It is a method that is called by the Java Virtual Machine (JVM) when the program is launched. The <code>main()</code> method is typically declared as <code>public static void main(String[] args)</code>. In this declaration, the keyword <code>static</code> is used to indicate that the method belongs to the class itself, rather than to any particular instance of the class. In this answer, we will explore the reasons why <code>main()</code> is declared as static.</p><ol><li><p>No object instantiation required<br>As mentioned earlier, the <code>main()</code> method is called by the JVM when the program is launched. At this point, no objects of the class have been instantiated yet. Therefore, the <code>main()</code> method needs to be declared as static so that it can be called without the need for any object instantiation.</p></li><li><p>Consistency with the JVM<br>The JVM is designed to call the <code>main()</code> method without instantiating any objects of the class. Therefore, declaring <code>main()</code> as static is consistent with the way the JVM works.</p></li><li><p>Access to static variables and methods<br>Static methods and variables belong to the class itself and not to any particular instance of the class. Since <code>main()</code> is a static method, it can access other static variables and methods of the class without the need for object instantiation. This can be useful in certain scenarios where the <code>main()</code> method needs to access static variables or methods of the class.</p></li></ol><p>Example:<br>Here is an example to illustrate the need for the <code>main()</code> method to be declared as static:</p><pre><div><div><code><span>public</span> <span>class</span> <span>MyClass</span> {<br>  <span>private</span> <span>int</span> x;<br><br>  <span><span>public</span> <span>void</span> <span>setX</span>(<span><span>int</span> <span>value</span></span>)</span> {<br>    x = <span>value</span>;<br>  }<br><br>  <span><span>public</span> <span>int</span> <span>getX</span>()</span> {<br>    <span>return</span> x;<br>  }<br><br>  <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>    MyClass obj = <span>new</span> MyClass();<br>    obj.setX(<span>10</span>);<br>    System.<span>out</span>.println(<span>\"Value of x is \"</span> + obj.getX());<br>  }<br>}<br></code></div></div></pre><p>In this example, we have a class <code>MyClass</code> with an instance variable <code>x</code>. We create an object of the class in the <code>main()</code> method and use it to set the value of <code>x</code> to 10. We then print the value of <code>x</code> using the <code>getX()</code> method.</p><p>If we were to declare the <code>main()</code> method as non-static, we would need to create an object of the class before we could call the <code>main()</code> method. However, this would create a chicken-and-egg problem because we cannot create an object of the class without first calling the <code>main()</code> method. Therefore, the <code>main()</code> method needs to be declared as static to avoid this problem.</p></div>"
            },
            {
                "ques": "What is a string? Write code to reverse the string as mentioned in the output?",
                "ans": "<div><p>In Java, a <code>String</code> is an object that represents a sequence of characters. Strings are immutable, which means that once a string is created, it cannot be modified. Instead, any operation that appears to modify a string actually creates a new string object.</p><p>To reverse a string in Java, we can use several approaches. Here are some examples:</p><p>Approach 1: Using a loop</p><p>One way to reverse a string is to iterate over the characters of the string and append them to a new string in reverse order. Here's an example code that demonstrates this approach:</p><pre><div><div><code><span>public</span> <span>class</span> <span>ReverseString</span> {<br>    <span>public</span> <span>static</span> <span>String</span> <span>reverse</span>(<span><span>String</span> str</span>) {<br>        <span>String</span> reversed = <span>\"\"</span>;<br>        <span>for</span> (int i = str.<span>length</span>() - <span>1</span>; i &gt;= <span>0</span>; i--) {<br>            reversed += str.<span>charAt</span>(i);<br>        }<br>        <span>return</span> reversed;<br>    }<br><br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span><span>String</span>[] args</span>) {<br>        <span>String</span> str = <span>\"hello world\"</span>;<br>        <span>String</span> reversed = <span>reverse</span>(str);<br>        <span>System</span>.<span>out</span>.<span>println</span>(reversed);<br>    }<br>}<br></code></div></div></pre><p>In this example, the <code>reverse()</code> method takes a <code>String</code> as an input, and returns a new <code>String</code> that is the reversed version of the input string. The method uses a <code>for</code> loop to iterate over the characters of the input string in reverse order, and appends them to a new string called <code>reversed</code>. Finally, the method returns the <code>reversed</code> string.</p><p>The <code>main()</code> method demonstrates how to use the <code>reverse()</code> method. We create a new <code>String</code> object with the value \"hello world\", and call the <code>reverse()</code> method to get the reversed string. We then print the reversed string to the console.</p><p>Approach 2: Using StringBuilder</p><p>Another way to reverse a string is to use a <code>StringBuilder</code> object. The <code>StringBuilder</code> class provides a <code>reverse()</code> method that allows us to reverse the characters in the string. Here's an example code that demonstrates this approach:</p><pre><div><div><code><span>public</span> <span>class</span> <span>ReverseString</span> {<br>    <span>public</span> <span>static</span> <span>String</span> <span>reverse</span>(<span><span>String</span> str</span>) {<br>        <span>StringBuilder</span> sb = <span>new</span> <span>StringBuilder</span>(str);<br>        <span>return</span> sb.<span>reverse</span>().<span>toString</span>();<br>    }<br><br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span><span>String</span>[] args</span>) {<br>        <span>String</span> str = <span>\"hello world\"</span>;<br>        <span>String</span> reversed = <span>reverse</span>(str);<br>        <span>System</span>.<span>out</span>.<span>println</span>(reversed);<br>    }<br>}<br></code></div></div></pre><p>In this example, the <code>reverse()</code> method takes a <code>String</code> as an input, and returns a new <code>String</code> that is the reversed version of the input string. The method creates a new <code>StringBuilder</code> object with the input string, and then calls the <code>reverse()</code> method to reverse the characters in the string. Finally, the method returns the reversed string.</p><p>The <code>main()</code> method demonstrates how to use the <code>reverse()</code> method. We create a new <code>String</code> object with the value \"hello world\", and call the <code>reverse()</code> method to get the reversed string. We then print the reversed string to the console.</p><p>Output:<br>The output for both approaches will be:</p><pre><div><div><code>dlrow olleh<br></code></div></div></pre><p>This is the reversed version of the input string \"hello world\".</p></div>"
            },
            {
                "ques": "Core Java concepts with examples in your framework? like interface, abstraction method overloading and overriding",
                "ans": "<div><p>As an AI language model, I don't have a personal framework, but I can explain the core Java concepts with examples. Here are some examples of Java concepts:</p><ol><li>Interface:</li></ol><p>An interface is a blueprint of a class that specifies a set of methods and their signatures, but doesn't provide any implementation details. A class that implements an interface must provide implementations for all the methods declared in the interface. Here's an example of an interface:</p><pre><div><div><code><span>public</span> <span>interface</span> <span>Shape</span> {<br>    <span><span>public</span> <span>double</span> <span>getArea</span>()</span>;<br>}<br></code></div></div></pre><p>In this example, <code>Shape</code> is an interface that declares a single method called <code>getArea()</code>, which returns a <code>double</code>. Any class that implements this interface must provide an implementation for the <code>getArea()</code> method.</p><ol start=\"2\"><li>Abstraction:</li></ol><p>Abstraction is the process of hiding implementation details while showing only the necessary details to the user. In Java, abstraction is achieved through abstract classes and interfaces. Abstract classes are classes that cannot be instantiated, but can be subclassed to provide implementations for their abstract methods. Here's an example of an abstract class:</p><pre><div><div><code><span>public</span> <span>abstract</span> <span>class</span> <span>Animal</span> {<br>    <span><span>public</span> <span>abstract</span> <span>void</span> <span>makeSound</span>()</span>;<br>}<br></code></div></div></pre><p>In this example, <code>Animal</code> is an abstract class that declares a single abstract method called <code>makeSound()</code>. Any subclass of <code>Animal</code> must provide an implementation for the <code>makeSound()</code> method.</p><ol start=\"3\"><li>Method overloading:</li></ol><p>Method overloading is the process of defining multiple methods with the same name but different parameter lists. When a method is called, the Java compiler selects the appropriate version of the method based on the parameters provided. Here's an example of method overloading:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Calculator</span> {<br>    <span>public</span> <span>int</span> <span>add</span><span>(<span>int</span> a, <span>int</span> b)</span> {<br>        <span>return</span> a + b;<br>    }<br><br>    <span>public</span> <span>double</span> <span>add</span><span>(<span>double</span> a, <span>double</span> b)</span> {<br>        <span>return</span> a + b;<br>    }<br>}<br></code></div></div></pre><p>In this example, the <code>Calculator</code> class defines two methods called <code>add()</code>. One method takes two <code>int</code> parameters and returns an <code>int</code>, while the other method takes two <code>double</code> parameters and returns a <code>double</code>. Depending on the types of the arguments passed to the method, the Java compiler will select the appropriate version of the <code>add()</code> method.</p><ol start=\"4\"><li>Method overriding:</li></ol><p>Method overriding is the process of providing a new implementation for a method that is already defined in a superclass. When a subclass overrides a method, the new implementation of the method is used instead of the original implementation in the superclass. Here's an example of method overriding:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Cat</span> <span>extends</span> <span>Animal</span> {<br>    <span><span>public</span> <span>void</span> <span>makeSound</span>()</span> {<br>        System.<span>out</span>.println(<span>\"Meow\"</span>);<br>    }<br>}<br></code></div></div></pre><p>In this example, <code>Cat</code> is a subclass of <code>Animal</code> that overrides the <code>makeSound()</code> method with a new implementation that prints \"Meow\" to the console. When the <code>makeSound()</code> method is called on a <code>Cat</code> object, the new implementation in the <code>Cat</code> class will be used instead of the original implementation in the <code>Animal</code> class.</p><p>These are just a few examples of core Java concepts. In practice, these concepts are often used together in more complex applications to create well-organized and maintainable code.</p></div>"
            },
            {
                "ques": "Difference between Assert and Verify in test automation using TestNG",
                "ans": "<div><p>In Java test automation using TestNG, two commonly used methods for verification are <code>Assert</code> and <code>Verify</code>. Both methods are used to verify whether a condition is true or false. However, there are some differences between the two that are important to understand.</p><ol><li><code>Assert</code>:</li></ol><p>The <code>Assert</code> method is used to verify that a condition is true. If the condition is false, the <code>Assert</code> method will throw an <code>AssertionError</code> and the test case will fail. Here's an example of using <code>Assert</code>:</p><pre><div><div><code><span>@Test</span><br><span>public</span> <span>void</span> <span>testAddition</span><span>()</span> {<br>    <span>int</span> <span>a</span> <span>=</span> <span>2</span>;<br>    <span>int</span> <span>b</span> <span>=</span> <span>3</span>;<br>    <span>int</span> <span>result</span> <span>=</span> a + b;<br>    Assert.assertEquals(result, <span>5</span>);<br>}<br></code></div></div></pre><p>In this example, the <code>Assert.assertEquals()</code> method verifies that the <code>result</code> of adding <code>a</code> and <code>b</code> is equal to <code>5</code>. If the result is not equal to <code>5</code>, the test case will fail with an <code>AssertionError</code>.</p><ol start=\"2\"><li><code>Verify</code>:</li></ol><p>The <code>Verify</code> method is also used to verify that a condition is true, but it doesn't throw an exception if the condition is false. Instead, it logs the failure and continues to execute the test case. Here's an example of using <code>Verify</code>:</p><pre><div><div><code><span>@Test</span><br><span>public</span> <span>void</span> <span>testAddition</span><span>()</span> {<br>    <span>int</span> <span>a</span> <span>=</span> <span>2</span>;<br>    <span>int</span> <span>b</span> <span>=</span> <span>3</span>;<br>    <span>int</span> <span>result</span> <span>=</span> a + b;<br>    <span>SoftAssert</span> <span>softAssert</span> <span>=</span> <span>new</span> <span>SoftAssert</span>();<br>    softAssert.assertEquals(result, <span>5</span>);<br>    softAssert.assertAll();<br>}<br></code></div></div></pre><p>In this example, the <code>SoftAssert</code> class is used to perform the verification. The <code>SoftAssert.assertEquals()</code> method verifies that the <code>result</code> of adding <code>a</code> and <code>b</code> is equal to <code>5</code>. However, the test case will continue to execute even if the condition is false. The <code>softAssert.assertAll()</code> method is called at the end of the test case to verify that all assertions have passed. If any assertion has failed, the test case will fail.</p><p>The main differences between <code>Assert</code> and <code>Verify</code> are:</p><ul><li><code>Assert</code> throws an exception and stops the test case when the condition is false, while <code>Verify</code> logs the failure and continues to execute the test case.</li><li><code>Assert</code> is typically used for critical checks that should stop the test case when they fail, while <code>Verify</code> is used for non-critical checks that should log the failure but allow the test case to continue.</li></ul><p>In general, it's a good practice to use <code>Assert</code> for critical checks and <code>Verify</code> for non-critical checks. However, the choice between the two methods ultimately depends on the requirements of the specific test case.</p></div>"
            },
            {
                "ques": "Difference bewteen checked and unchecked exceptions",
                "ans": "<div><p>In Java, exceptions can be divided into two categories: checked exceptions and unchecked exceptions. Both types of exceptions serve different purposes, and understanding the differences between them is crucial to writing reliable and robust code.</p><p>Checked Exceptions:<br>Checked exceptions are the exceptions that must be declared in the method signature using the <code>throws</code> keyword. A checked exception is a type of exception that is checked at compile time. These exceptions must be handled by the calling code or propagated further up the call stack. The purpose of checked exceptions is to ensure that the code handles known exceptional situations that may arise during program execution.</p><p>For example, if you are trying to read from a file that does not exist, a <code>FileNotFoundException</code> will be thrown, which is a checked exception. Here's an example of how to handle a checked exception:</p><pre><div><div><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> <span>throws</span> FileNotFoundException {<br>    <span>File</span> <span>file</span> <span>=</span> <span>new</span> <span>File</span>(<span>\"myfile.txt\"</span>);<br>    <span>Scanner</span> <span>scanner</span> <span>=</span> <span>new</span> <span>Scanner</span>(file);<br>}<br></code></div></div></pre><p>In this example, the <code>Scanner</code> constructor throws a <code>FileNotFoundException</code>, which is a checked exception. The exception is declared in the <code>main</code> method signature using the <code>throws</code> keyword.</p><p>Unchecked Exceptions:<br>Unchecked exceptions, also known as runtime exceptions, are the exceptions that do not have to be declared in the method signature. They are not checked at compile time, and they can occur at runtime. Unchecked exceptions are not required to be handled by the calling code, but it is still a good practice to handle them. These exceptions typically represent bugs in the code, such as null pointer exceptions, array index out of bounds exceptions, and arithmetic exceptions.</p><p>For example, consider the following code that divides two integers:</p><pre><div><div><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>    <span>int</span> <span>a</span> <span>=</span> <span>10</span>;<br>    <span>int</span> <span>b</span> <span>=</span> <span>0</span>;<br>    <span>int</span> <span>c</span> <span>=</span> a / b;<br>}<br></code></div></div></pre><p>In this example, the value of <code>b</code> is <code>0</code>, which results in an <code>ArithmeticException</code>, which is an unchecked exception. The exception is not declared in the method signature, and the program will crash if the exception is not handled properly.</p><p>The main differences between checked and unchecked exceptions are:</p><ul><li>Checked exceptions must be declared in the method signature or handled by the calling code, while unchecked exceptions do not have to be declared or handled.</li><li>Checked exceptions are typically used for expected exceptional situations, while unchecked exceptions are used to indicate unexpected exceptional situations.</li></ul><p>In general, it's a good practice to use checked exceptions for expected exceptional situations, such as IO errors or network errors, while using unchecked exceptions for unexpected exceptional situations, such as null pointer exceptions or arithmetic exceptions. By following these practices, you can write reliable and robust code that handles exceptions properly.</p></div>"
            },
            {
                "ques": "Difference between Assert and Verify in test automation using TestNG",
                "ans": "<div><p>In TestNG, there are two ways to check if a test case is successful or not: <code>assert</code> and <code>verify</code>. Both are used for validation purposes, but there are some differences between them.</p><p><code>Assert</code>:<br><code>Assert</code> is a built-in TestNG method that is used to verify if a certain condition is true or false. If the condition is false, the test case will be marked as failed, and the remaining steps of the test case will be skipped. The <code>assert</code> method is used to check the expected behavior of the application, and it will terminate the test case immediately if the assertion fails.</p><p>Here is an example of using <code>assert</code> in TestNG:</p><pre><div><div><code><span>@Test</span><br><span>public</span> <span>void</span> <span>testAddition</span><span>()</span> {<br>   <span>int</span> <span>a</span> <span>=</span> <span>10</span>;<br>   <span>int</span> <span>b</span> <span>=</span> <span>20</span>;<br>   <span>int</span> <span>sum</span> <span>=</span> a + b;<br>   Assert.assertEquals(sum, <span>30</span>);<br>}<br></code></div></div></pre><p>In this example, the <code>assertEquals</code> method of the <code>Assert</code> class is used to check if the sum of <code>a</code> and <code>b</code> is equal to 30. If the assertion fails, the test case will be marked as failed.</p><p><code>Verify</code>:<br><code>Verify</code> is also a built-in TestNG method that is used to verify if a certain condition is true or false. However, if the condition is false, the test case will not be marked as failed, and the remaining steps of the test case will continue to execute. The <code>verify</code> method is used to check the actual behavior of the application, and it will not terminate the test case immediately if the verification fails.</p><p>Here is an example of using <code>verify</code> in TestNG:</p><pre><div><div><code><span>@Test</span><br><span>public</span> <span>void</span> <span>testAddition</span><span>()</span> {<br>   <span>int</span> <span>a</span> <span>=</span> <span>10</span>;<br>   <span>int</span> <span>b</span> <span>=</span> <span>20</span>;<br>   <span>int</span> <span>sum</span> <span>=</span> a + b;<br>   <span>SoftAssert</span> <span>softAssert</span> <span>=</span> <span>new</span> <span>SoftAssert</span>();<br>   softAssert.assertEquals(sum, <span>30</span>);<br>   softAssert.assertAll();<br>}<br></code></div></div></pre><p>In this example, the <code>assertEquals</code> method of the <code>SoftAssert</code> class is used to check if the sum of <code>a</code> and <code>b</code> is equal to 30. If the verification fails, the test case will not be marked as failed, and the <code>assertAll</code> method is called at the end of the test case to mark the test case as failed if any verification fails.</p><p>The main difference between <code>assert</code> and <code>verify</code> is that <code>assert</code> is used to check the expected behavior of the application, while <code>verify</code> is used to check the actual behavior of the application. <code>Assert</code> will terminate the test case immediately if the assertion fails, while <code>verify</code> will not terminate the test case and will continue to execute the remaining steps of the test case.</p></div>"
            },
            {
                "ques": "What is bubble sort can you write one program",
                "ans": "<div><p>Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.</p><p>Here is an example program in Java that demonstrates the bubble sort algorithm:</p><pre><div><div><code><span>public</span> <span>class</span> <span>BubbleSort</span> {<br>    <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>        <span>int</span>[] arr = {<span>5</span>, <span>2</span>, <span>8</span>, <span>4</span>, <span>7</span>};<br>        <span>int</span> n = arr.length;<br><br>        <span>// Perform bubble sort</span><br>        <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; n - <span>1</span>; i++) {<br>            <span>for</span> (<span>int</span> j = <span>0</span>; j &lt; n - i - <span>1</span>; j++) {<br>                <span>if</span> (arr[j] &gt; arr[j + <span>1</span>]) {<br>                    <span>int</span> temp = arr[j];<br>                    arr[j] = arr[j + <span>1</span>];<br>                    arr[j + <span>1</span>] = temp;<br>                }<br>            }<br>        }<br><br>        <span>// Print the sorted array</span><br>        System.<span>out</span>.print(<span>\"Sorted array: \"</span>);<br>        <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; n; i++) {<br>            System.<span>out</span>.print(arr[i] + <span>\" \"</span>);<br>        }<br>    }<br>}<br></code></div></div></pre><p>In this example, we have an array <code>arr</code> with the values {5, 2, 8, 4, 7}. The bubble sort algorithm is performed on this array, and the sorted array is printed to the console.</p><p>The outer loop of the bubble sort algorithm runs <code>n-1</code> times, where <code>n</code> is the length of the array. The inner loop runs <code>n-i-1</code> times, where <code>i</code> is the index of the outer loop. This is because the largest value will always be at the end of the array after each pass, so we don't need to compare it again.</p><p>In the inner loop, we compare adjacent elements and swap them if they are in the wrong order. After each pass, the largest value is moved to the end of the array. This process is repeated until the array is sorted.</p><p>The output of the above program will be:</p><pre><div><div><code>Sorted <span>array</span>: <span>2</span> <span>4</span> <span>5</span> <span>7</span> <span>8</span><br></code></div></div></pre></div>"
            },
            {
                "ques": "Can we keep any name instead of args?",
                "ans": "<div><p>In Java, the <code>main</code> method is the entry point of the program, and it must have the following signature:</p><pre><div><div><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span><br></code></div></div></pre><p>The <code>args</code> parameter is an array of strings that contains any command line arguments passed to the program. The name <code>args</code> is just a convention, and it can be replaced with any valid Java identifier. However, it is recommended to use the name <code>args</code> for clarity and consistency with other Java programs.</p><p>For example, the following program replaces the <code>args</code> parameter with <code>arguments</code>:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Example</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] arguments)</span> {<br>        System.out.println(<span>\"Arguments: \"</span>);<br>        <span>for</span> (String arg : arguments) {<br>            System.out.println(arg);<br>        }<br>    }<br>}<br></code></div></div></pre><p>In this example, we loop through the <code>arguments</code> array and print each command line argument to the console.</p><p>When we run the program with the command line arguments \"foo\" and \"bar\", the output will be:</p><pre><div><div><code><span>Arguments:</span><br>foo<br>bar<br></code></div></div></pre><p>As you can see, the program works as expected, and the name of the <code>args</code> parameter is just a matter of convention. However, it is important to use a descriptive name that reflects the purpose of the parameter for the sake of readability and maintainability.</p></div>"
            },
            {
                "ques": "What are Abstract class and Interface? Difference between them?",
                "ans": "<div><p>In Java, an abstract class and an interface are two distinct but related concepts that allow you to define common behavior for classes.</p><p>An abstract class is a class that cannot be instantiated directly and serves as a base class for other classes. It can contain both concrete and abstract methods, and can also have instance variables and constructors. An abstract method is a method that is declared but not implemented in the abstract class, and must be implemented in the subclasses that inherit from the abstract class. An abstract class can be thought of as a partially implemented class, and it can be extended by other classes to provide a complete implementation.</p><p>Here is an example of an abstract class in Java:</p><pre><div><div><code><span>public</span> <span>abstract</span> <span>class</span> <span>Animal</span> {<br>    <span>protected</span> <span>int</span> legs;<br><br>    <span>public</span> <span>Animal</span><span>(<span>int</span> legs)</span> {<br>        <span>this</span>.legs = legs;<br>    }<br><br>    <span>public</span> <span>abstract</span> <span>void</span> <span>makeSound</span><span>()</span>;<br><br>    <span>public</span> <span>void</span> <span>walk</span><span>()</span> {<br>        System.out.println(<span>\"This animal is walking on \"</span> + legs + <span>\" legs.\"</span>);<br>    }<br>}<br></code></div></div></pre><p>In this example, <code>Animal</code> is an abstract class that has an abstract method <code>makeSound()</code> and a concrete method <code>walk()</code>. The <code>legs</code> instance variable and constructor are also included.</p><p>An interface, on the other hand, is a collection of abstract methods and constants that can be implemented by any class. It defines a contract that classes must follow in order to provide a certain functionality. An interface can only contain abstract methods, constants, and default methods (which are concrete methods with a default implementation). An interface can be thought of as a blueprint for a class, and it is used to provide a common behavior among unrelated classes.</p><p>Here is an example of an interface in Java:</p><pre><div><div><code><span>public</span> <span>interface</span> <span>Vehicle</span> {<br>    <span>void</span> <span>start</span><span>()</span>;<br>    <span>void</span> <span>stop</span><span>()</span>;<br>    <span>default</span> <span>void</span> <span>drive</span><span>()</span> {<br>        System.out.println(<span>\"This vehicle is driving.\"</span>);<br>    }<br>}<br></code></div></div></pre><p>In this example, <code>Vehicle</code> is an interface that defines three methods: <code>start()</code>, <code>stop()</code>, and <code>drive()</code>. The <code>drive()</code> method has a default implementation.</p><p>The main differences between an abstract class and an interface in Java are as follows:</p><ol><li>An abstract class can have both abstract and concrete methods, while an interface can only have abstract methods (with the exception of default methods).</li><li>A class can only extend one abstract class, but it can implement multiple interfaces.</li><li>An abstract class can have instance variables and constructors, while an interface cannot.</li><li>An abstract class is used when you want to provide a partial implementation for a class hierarchy, while an interface is used when you want to provide a common behavior among unrelated classes.</li></ol><p>In summary, an abstract class and an interface in Java are two related but distinct concepts that allow you to define common behavior for classes. The main difference between them is that an abstract class is a partially implemented class that can be extended by other classes, while an interface is a collection of abstract methods and constants that can be implemented by any class.</p></div>"
            },
            {
                "ques": "What are hashmap and HashSet? Explain?",
                "ans": "<div><p>HashMap and HashSet are two important data structures in Java that are used to store and manage collections of objects.</p><p>HashMap is a key-value mapping data structure that allows you to store and retrieve elements based on a key. It implements the Map interface and is part of the Java Collections Framework. A HashMap contains a set of key-value pairs, where each key is unique and is used to retrieve the corresponding value. The keys and values can be of any object type, including null.</p><p>Here is an example of how to create and use a HashMap in Java:</p><pre><div><div><code><span>import</span> java.util.HashMap;<br><br><span>public</span> <span>class</span> <span>Example</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>        <span>// create a new HashMap</span><br>        HashMap&lt;String, Integer&gt; map = <span>new</span> <span>HashMap</span>&lt;String, Integer&gt;();<br><br>        <span>// add some key-value pairs to the HashMap</span><br>        map.put(<span>\"apple\"</span>, <span>1</span>);<br>        map.put(<span>\"orange\"</span>, <span>2</span>);<br>        map.put(<span>\"banana\"</span>, <span>3</span>);<br><br>        <span>// retrieve the value for a key</span><br>        <span>int</span> <span>value</span> <span>=</span> map.get(<span>\"apple\"</span>);<br><br>        <span>// iterate over the key-value pairs in the HashMap</span><br>        <span>for</span> (String key : map.keySet()) {<br>            <span>int</span> <span>value</span> <span>=</span> map.get(key);<br>            System.out.println(key + <span>\" = \"</span> + value);<br>        }<br>    }<br>}<br></code></div></div></pre><p>In this example, a HashMap is created that maps String keys to Integer values. Some key-value pairs are added to the HashMap, and then a value is retrieved for a specific key. Finally, the key-value pairs in the HashMap are iterated over and printed to the console.</p><p>HashSet, on the other hand, is a set data structure that allows you to store a collection of unique elements. It implements the Set interface and is also part of the Java Collections Framework. A HashSet contains no duplicate elements and the elements can be of any object type, including null.</p><p>Here is an example of how to create and use a HashSet in Java:</p><pre><div><div><code><span>import</span> java.util.HashSet;<br><br><span>public</span> <span>class</span> <span>Example</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>        <span>// create a new HashSet</span><br>        HashSet&lt;String&gt; set = <span>new</span> <span>HashSet</span>&lt;String&gt;();<br><br>        <span>// add some elements to the HashSet</span><br>        set.add(<span>\"apple\"</span>);<br>        set.add(<span>\"orange\"</span>);<br>        set.add(<span>\"banana\"</span>);<br>        set.add(<span>\"apple\"</span>);<br><br>        <span>// iterate over the elements in the HashSet</span><br>        <span>for</span> (String element : set) {<br>            System.out.println(element);<br>        }<br>    }<br>}<br></code></div></div></pre><p>In this example, a HashSet is created that contains a collection of unique String elements. Some elements are added to the HashSet, including a duplicate element. Finally, the elements in the HashSet are iterated over and printed to the console, but only the unique elements are printed.</p><p>In summary, HashMap and HashSet are two important data structures in Java that are used to store and manage collections of objects. HashMap is a key-value mapping data structure that allows you to store and retrieve elements based on a key, while HashSet is a set data structure that allows you to store a collection of unique elements.</p></div>"
            },
            {
                "ques": "Where do we use the hashmap in our selenium automation framework?",
                "ans": "<div><p>In Selenium automation framework, HashMap can be used to store data in key-value pairs. This can be useful when we want to store some data for later use, such as storing data from a webpage and then using it in a later test case. Here are some examples of where HashMap can be used in a Selenium automation framework:</p><ol><li><p>Storing test data: In automated testing, we often need to store test data that will be used by multiple test cases. Instead of storing this data in a separate file or database, we can use a HashMap to store this data in memory. For example, we can store login credentials in a HashMap and use them in multiple test cases.</p></li><li><p>Storing page elements: When automating web applications, we often need to interact with various page elements such as buttons, input fields, and links. We can use a HashMap to store these elements by their names or IDs, so that we can easily access them later in our test cases. For example, we can store the login button on a login page in a HashMap, and then click on it in a later test case.</p></li></ol><p>Here is an example of how to use HashMap in a Selenium automation framework:</p><pre><div><div><code><span>import</span> java.util.HashMap;<br><span>import</span> org.openqa.selenium.By;<br><span>import</span> org.openqa.selenium.WebDriver;<br><span>import</span> org.openqa.selenium.WebElement;<br><span>import</span> org.openqa.selenium.chrome.ChromeDriver;<br><br><span>public</span> <span>class</span> <span>Example</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>        <span>// create a new HashMap to store page elements</span><br>        HashMap&lt;String, By&gt; elements = <span>new</span> <span>HashMap</span>&lt;String, By&gt;();<br>        elements.put(<span>\"username\"</span>, By.id(<span>\"username\"</span>));<br>        elements.put(<span>\"password\"</span>, By.id(<span>\"password\"</span>));<br>        elements.put(<span>\"loginButton\"</span>, By.id(<span>\"loginButton\"</span>));<br><br>        <span>// create a new WebDriver instance</span><br>        <span>WebDriver</span> <span>driver</span> <span>=</span> <span>new</span> <span>ChromeDriver</span>();<br><br>        <span>// navigate to a web page</span><br>        driver.get(<span>\"https://example.com/login\"</span>);<br><br>        <span>// find the username and password input fields and login button</span><br>        <span>WebElement</span> <span>usernameField</span> <span>=</span> driver.findElement(elements.get(<span>\"username\"</span>));<br>        <span>WebElement</span> <span>passwordField</span> <span>=</span> driver.findElement(elements.get(<span>\"password\"</span>));<br>        <span>WebElement</span> <span>loginButton</span> <span>=</span> driver.findElement(elements.get(<span>\"loginButton\"</span>));<br><br>        <span>// enter login credentials and click the login button</span><br>        usernameField.sendKeys(<span>\"username\"</span>);<br>        passwordField.sendKeys(<span>\"password\"</span>);<br>        loginButton.click();<br>    }<br>}<br></code></div></div></pre><p>In this example, a HashMap is used to store page elements on a login page, such as the username and password input fields and the login button. These elements are stored in the HashMap using their IDs as keys. The WebDriver instance then navigates to the login page and finds the page elements using the HashMap. Finally, the login credentials are entered and the login button is clicked.</p><p>In summary, HashMap can be used in a Selenium automation framework to store data in key-value pairs, such as test data and page elements. This can make it easier to write and maintain automated tests.</p></div>"
            },
            {
                "ques": "Write a program using a hashmap to add and retrieve data and print it in the console.",
                "ans": "<div><p>Here is an example program in Java that uses a HashMap to add and retrieve data, and print it in the console:</p><pre><div><div><code><span>import</span> java.util.HashMap;<br><br><span>public</span> <span>class</span> <span>HashMapExample</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>        <span>// create a new HashMap to store data</span><br>        HashMap&lt;Integer, String&gt; map = <span>new</span> <span>HashMap</span>&lt;Integer, String&gt;();<br><br>        <span>// add data to the HashMap</span><br>        map.put(<span>1</span>, <span>\"John\"</span>);<br>        map.put(<span>2</span>, <span>\"Jane\"</span>);<br>        map.put(<span>3</span>, <span>\"Bob\"</span>);<br>        map.put(<span>4</span>, <span>\"Alice\"</span>);<br><br>        <span>// retrieve data from the HashMap and print it in the console</span><br>        System.out.println(<span>\"Data in the HashMap:\"</span>);<br>        System.out.println(<span>\"Key: 1, Value: \"</span> + map.get(<span>1</span>));<br>        System.out.println(<span>\"Key: 2, Value: \"</span> + map.get(<span>2</span>));<br>        System.out.println(<span>\"Key: 3, Value: \"</span> + map.get(<span>3</span>));<br>        System.out.println(<span>\"Key: 4, Value: \"</span> + map.get(<span>4</span>));<br>    }<br>}<br></code></div></div></pre><p>In this example, we create a new HashMap to store data, with integer keys and string values. We then add some data to the HashMap using the <code>put()</code> method. We then retrieve the data from the HashMap using the <code>get()</code> method and print it in the console.</p><p>The output of this program will be:</p><pre><div><div><code><span>Data in the HashMap:</span><br><span>Key:</span> <span>1</span><span>,</span> <span>Value:</span> <span>John</span><br><span>Key:</span> <span>2</span><span>,</span> <span>Value:</span> <span>Jane</span><br><span>Key:</span> <span>3</span><span>,</span> <span>Value:</span> <span>Bob</span><br><span>Key:</span> <span>4</span><span>,</span> <span>Value:</span> <span>Alice</span><br></code></div></div></pre><p>This shows that we were able to successfully add data to the HashMap and retrieve it using the keys. We then printed the data in the console using the <code>println()</code> method.</p><p>In summary, HashMap can be used to store data in key-value pairs, and can be useful when we want to store data for later use. This example program demonstrates how to use a HashMap to add and retrieve data, and print it in the console.</p></div>"
            },
            {
                "ques": "what is an Exception? How to handle Exceptions?",
                "ans": "<div><p>In Java, an exception is an event that occurs during the execution of a program that disrupts the normal flow of the program's instructions. An exception can occur for various reasons, such as a program error, a user error, or an external event.</p><p>When an exception occurs, the Java Virtual Machine (JVM) creates an exception object to represent the exception. This exception object contains information about the exception, such as the type of exception and the location in the code where the exception occurred.</p><p>To handle an exception in Java, we use try-catch blocks. A try block contains the code that may cause an exception, and a catch block contains the code to handle the exception if it occurs. Here is an example code snippet that shows how to use try-catch blocks to handle an exception:</p><pre><div><div><code><span>try</span> {<br>    <span>// code that may cause an exception</span><br>} <span>catch</span> (Exception e) {<br>    <span>// code to handle the exception</span><br>}<br></code></div></div></pre><p>In this code, the <code>try</code> block contains the code that may cause an exception. If an exception occurs, it is caught by the <code>catch</code> block, which contains the code to handle the exception. The exception object is passed as a parameter to the catch block, which allows us to access information about the exception.</p><p>For example, let's say we have a method that divides two numbers. If the denominator is 0, it will result in an ArithmeticException. Here's an example code snippet that shows how to handle this exception:</p><pre><div><div><code><span>int</span> <span>numerator</span> <span>=</span> <span>10</span>;<br><span>int</span> <span>denominator</span> <span>=</span> <span>0</span>;<br><br><span>try</span> {<br>    <span>int</span> <span>result</span> <span>=</span> numerator / denominator;<br>    System.out.println(result);<br>} <span>catch</span> (ArithmeticException e) {<br>    System.out.println(<span>\"Cannot divide by zero.\"</span>);<br>}<br></code></div></div></pre><p>In this code, we try to divide the numerator by the denominator. Since the denominator is 0, it will result in an ArithmeticException. This exception is caught by the <code>catch</code> block, which prints a message saying that we cannot divide by zero.</p><p>The output of this program will be:</p><pre><div><div><code>Cannot divide <span>by</span> zero.<br></code></div></div></pre><p>In summary, an exception is an event that occurs during the execution of a program that disrupts the normal flow of the program's instructions. To handle an exception in Java, we use try-catch blocks, which allows us to catch the exception and handle it appropriately.</p></div>"
            },
            {
                "ques": "What is encapsulation in java and how do we use it in selenium testing framework?",
                "ans": "<div><p>Encapsulation is one of the fundamental concepts of object-oriented programming. It is the mechanism of hiding the implementation details of a class and providing a public interface through which the outside world can interact with the class. In Java, encapsulation is achieved through the use of access modifiers such as private, protected, and public.</p><p>Encapsulation provides several benefits, such as improving code maintainability, enhancing code reusability, and reducing code complexity. In a Selenium testing framework, encapsulation can be used to hide the implementation details of the test automation code and provide a simple and easy-to-use public interface for interacting with the test automation code.</p><p>Here's an example of how encapsulation can be used in a Selenium testing framework. Let's say we have a page object class that represents a login page. The implementation details of the login page are hidden from the outside world, and we provide a public interface for interacting with the page.</p><pre><div><div><code><span>public</span> <span>class</span> <span>LoginPage</span> {<br>    <span>private</span> WebDriver driver;<br>    <span>private</span> WebElement usernameField;<br>    <span>private</span> WebElement passwordField;<br>    <span>private</span> WebElement loginButton;<br><br>    <span>public</span> <span>LoginPage</span><span>(WebDriver driver)</span> {<br>        <span>this</span>.driver = driver;<br>        <span>this</span>.usernameField = driver.findElement(By.id(<span>\"username\"</span>));<br>        <span>this</span>.passwordField = driver.findElement(By.id(<span>\"password\"</span>));<br>        <span>this</span>.loginButton = driver.findElement(By.id(<span>\"loginButton\"</span>));<br>    }<br><br>    <span>public</span> <span>void</span> <span>setUsername</span><span>(String username)</span> {<br>        <span>this</span>.usernameField.sendKeys(username);<br>    }<br><br>    <span>public</span> <span>void</span> <span>setPassword</span><span>(String password)</span> {<br>        <span>this</span>.passwordField.sendKeys(password);<br>    }<br><br>    <span>public</span> <span>void</span> <span>clickLoginButton</span><span>()</span> {<br>        <span>this</span>.loginButton.click();<br>    }<br>}<br></code></div></div></pre><p>In this code, the details of the login page are hidden from the outside world using the private access modifier. We provide a public constructor that accepts a WebDriver object and initializes the private fields. We also provide public methods for setting the username and password fields and clicking the login button.</p><p>Using encapsulation in this way provides several benefits. The implementation details of the login page are hidden, which reduces code complexity and improves code maintainability. The public interface for interacting with the page is simple and easy to use, which enhances code reusability and makes the test automation code more readable and understandable.</p><p>In summary, encapsulation is a fundamental concept of object-oriented programming that is used to hide the implementation details of a class and provide a public interface for interacting with the class. In a Selenium testing framework, encapsulation can be used to hide the implementation details of the test automation code and provide a simple and easy-to-use public interface for interacting with the test automation code.</p></div>"
            },
            {
                "ques": "What is abstraction in java and how do we use it in selenium testing framework?",
                "ans": "<div><p>Abstraction is one of the fundamental concepts of object-oriented programming that allows us to focus on the essential features of an object and ignore the details that are not relevant to our needs. In Java, abstraction is achieved through the use of abstract classes and interfaces.</p><p>An abstract class is a class that cannot be instantiated and is designed to be subclassed by other classes. It contains abstract methods, which are methods that do not have an implementation in the abstract class and must be implemented by the subclass. An interface is similar to an abstract class, but it only contains method signatures and does not have any implementation.</p><p>In a Selenium testing framework, abstraction can be used to create a set of generic classes and interfaces that can be reused across multiple tests. For example, we can create an abstract class that represents a page in our application and define a set of common methods and properties that are applicable to all pages in our application. We can then create subclasses of this abstract class that represent specific pages in our application and implement the abstract methods as needed.</p><p>Here's an example of how abstraction can be used in a Selenium testing framework. Let's say we have an abstract page class that represents a page in our application. This class contains common methods and properties that are applicable to all pages in our application.</p><pre><div><div><code><span>public</span> <span>abstract</span> <span>class</span> <span>Page</span> {<br>    <span>protected</span> WebDriver driver;<br><br>    <span>public</span> <span>Page</span><span>(WebDriver driver)</span> {<br>        <span>this</span>.driver = driver;<br>    }<br><br>    <span>public</span> <span>abstract</span> String <span>getPageTitle</span><span>()</span>;<br><br>    <span>public</span> <span>abstract</span> WebElement <span>findElement</span><span>(By by)</span>;<br><br>    <span>public</span> <span>void</span> <span>navigateTo</span><span>(String url)</span> {<br>        driver.get(url);<br>    }<br><br>    <span>public</span> <span>void</span> <span>maximizeWindow</span><span>()</span> {<br>        driver.manage().window().maximize();<br>    }<br>}<br></code></div></div></pre><p>In this code, the Page class is an abstract class that contains a reference to the WebDriver object and a set of common methods that are applicable to all pages in our application. The getPageTitle and findElement methods are abstract and must be implemented by the subclass.</p><p>Using abstraction in this way provides several benefits. It allows us to create a set of generic classes and interfaces that can be reused across multiple tests, which reduces code duplication and improves code maintainability. It also allows us to focus on the essential features of an object and ignore the details that are not relevant to our needs, which makes the test automation code more readable and understandable.</p><p>In summary, abstraction is a fundamental concept of object-oriented programming that allows us to focus on the essential features of an object and ignore the details that are not relevant to our needs. In a Selenium testing framework, abstraction can be used to create a set of generic classes and interfaces that can be reused across multiple tests, which reduces code duplication and improves code maintainability.</p></div>"
            },
            {
                "ques": "What is function overloading? Can we overload the main method?",
                "ans": "<div><p>In Java, function overloading refers to the practice of creating multiple methods within a class that have the same name but different parameters. The main purpose of function overloading is to provide an alternative method to invoke the same functionality with different input parameters.</p><p>We can overload any method in Java, including the main method. The main method can be overloaded by defining another method with the same name but different parameter lists. However, only the original main method with the string array parameter list is recognized as the program entry point.</p><p>Here's an example of function overloading in Java:</p><pre><div><div><code><span>public</span> <span>class</span> <span>OverloadExample</span> {<br>   <span><span>public</span> <span>int</span> <span>sum</span>(<span><span>int</span> x, <span>int</span> y</span>)</span> {<br>      <span>return</span> x + y;<br>   }<br>   <br>   <span><span>public</span> <span>double</span> <span>sum</span>(<span><span>double</span> x, <span>double</span> y</span>)</span> {<br>      <span>return</span> x + y;<br>   }<br>   <br>   <span><span>public</span> String <span>sum</span>(<span>String x, String y</span>)</span> {<br>      <span>return</span> x + y;<br>   }<br>   <br>   <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>      OverloadExample obj = <span>new</span> OverloadExample();<br>      System.<span>out</span>.println(obj.sum(<span>10</span>, <span>20</span>));<br>      System.<span>out</span>.println(obj.sum(<span>10.5</span>, <span>20.5</span>));<br>      System.<span>out</span>.println(obj.sum(<span>\"Hello\"</span>, <span>\" World\"</span>));<br>   }<br>}<br></code></div></div></pre><p>In the above example, we have created three overloaded <code>sum()</code> methods in the <code>OverloadExample</code> class. The first <code>sum()</code> method takes two integer parameters and returns their sum, the second method takes two double parameters and returns their sum, and the third method takes two string parameters and returns their concatenation.</p><p>In the main method, we have created an object of the <code>OverloadExample</code> class and called the <code>sum()</code> method with different parameter lists. The output of the program will be:</p><pre><div><div><code>30<br>31.0<br>Hello World<br></code></div></div></pre><p>As you can see, the Java compiler is able to differentiate between the different overloaded <code>sum()</code> methods based on the number and type of their parameters, and invokes the appropriate method at runtime.</p></div>"
            },
            {
                "ques": "Where do we use the hashmap in our selenium automation framework?",
                "ans": "<div><p>In a Selenium automation framework, the <code>HashMap</code> data structure can be used to store and manage test data efficiently. One common use case is to store test data such as test inputs, expected results, and actual results in a <code>HashMap</code> object.</p><p>For example, let's say we have a test scenario that involves entering different username-password combinations and checking if the login is successful. We can store the test data in a <code>HashMap</code> object as follows:</p><pre><div><div><code><span>HashMap</span>&lt;<span>String</span>, <span>String</span>&gt; testData = <span>new</span> <span>HashMap</span>&lt;<span>String</span>, <span>String</span>&gt;();<br>testData.<span>put</span>(<span>\"user1\"</span>, <span>\"password1\"</span>);<br>testData.<span>put</span>(<span>\"user2\"</span>, <span>\"password2\"</span>);<br>testData.<span>put</span>(<span>\"user3\"</span>, <span>\"password3\"</span>);<br></code></div></div></pre><p>In the above example, we have created a <code>HashMap</code> object named <code>testData</code> that maps <code>String</code> keys (the usernames) to <code>String</code> values (the passwords). We can add as many key-value pairs to the <code>HashMap</code> as we want.</p><p>We can then use the <code>HashMap</code> object to retrieve the test data and perform the test steps in our automation script. For example:</p><pre><div><div><code>for (String username : testData.keySet()) {<br>   String password = testData<span>.get</span>(username);<br>   LoginPage loginPage = new <span>LoginPage</span>(driver);<br>   loginPage<span>.enterUsername</span>(username);<br>   loginPage<span>.enterPassword</span>(password);<br>   loginPage<span>.clickLoginButton</span>();<br>   <span>// perform assertion to check if login is successful</span><br>}<br></code></div></div></pre><p>In the above example, we have used a <code>for</code> loop to iterate over the keys of the <code>testData</code> <code>HashMap</code>. For each key, we retrieve the corresponding password value using the <code>get()</code> method. We then use the retrieved username and password to perform the login test steps.</p><p>The <code>HashMap</code> data structure provides a fast and efficient way to store and retrieve key-value pairs, making it ideal for managing test data in a Selenium automation framework.</p></div>"
            },
            {
                "ques": "How to handle checked exceptions?",
                "ans": "<div><p>Checked exceptions in Java are those that the compiler checks at compile-time, meaning that the programmer must explicitly handle or declare them. This is in contrast to unchecked exceptions, which the compiler does not check and do not require explicit handling. Examples of checked exceptions include <code>IOException</code>, <code>SQLException</code>, and <code>ClassNotFoundException</code>.</p><p>There are two ways to handle checked exceptions in Java: using a try-catch block or declaring the exception using the <code>throws</code> keyword.</p><ol><li>Using a try-catch block</li></ol><p>A try-catch block can be used to catch and handle a checked exception at runtime. The syntax of a try-catch block is as follows:</p><pre><div><div><code><span>try</span> {<br>  <span>// code that may throw a checked exception</span><br>} <span>catch</span> (<span>Exception</span> e) {<br>  <span>// handle the exception</span><br>}<br></code></div></div></pre><p>In the above code, the code that may throw a checked exception is enclosed within the <code>try</code> block. If an exception is thrown, the catch block will handle it.</p><p>Here's an example of using a try-catch block to handle a checked exception:</p><pre><div><div><code><span>try</span> {<br>  <span>FileReader</span> <span>fileReader</span> <span>=</span> <span>new</span> <span>FileReader</span>(<span>\"file.txt\"</span>);<br>} <span>catch</span> (FileNotFoundException e) {<br>  System.out.println(<span>\"The file was not found.\"</span>);<br>}<br></code></div></div></pre><p>In this example, we attempt to create a <code>FileReader</code> object for a file that may not exist. If the file does not exist, a <code>FileNotFoundException</code> is thrown. We catch the exception using a try-catch block and print a message to the console.</p><ol start=\"2\"><li>Declaring the exception</li></ol><p>Another way to handle a checked exception is to declare the exception using the <code>throws</code> keyword. This is done by adding the <code>throws</code> clause to the method signature. For example:</p><pre><div><div><code><span>public</span> <span>void</span> <span>readFile</span><span>()</span> <span>throws</span> FileNotFoundException {<br>  <span>FileReader</span> <span>fileReader</span> <span>=</span> <span>new</span> <span>FileReader</span>(<span>\"file.txt\"</span>);<br>}<br></code></div></div></pre><p>In the above code, the <code>readFile()</code> method may throw a <code>FileNotFoundException</code>. We declare this by adding <code>throws FileNotFoundException</code> to the method signature.</p><p>When calling a method that throws a checked exception, the calling method must either handle the exception or declare it using the <code>throws</code> keyword.</p><pre><div><div><code><span><span>public</span> <span>void</span> <span>readAndPrintFile</span>()</span> {<br>  <span>try</span> {<br>    readFile();<br>  } <span>catch</span> (FileNotFoundException e) {<br>    System.<span>out</span>.println(<span>\"The file was not found.\"</span>);<br>  }<br>}<br></code></div></div></pre><p>In the above code, we call the <code>readFile()</code> method, which may throw a <code>FileNotFoundException</code>. We handle the exception using a try-catch block. If we did not handle the exception, we would need to declare it using the <code>throws</code> keyword in the <code>readAndPrintFile()</code> method signature.</p></div>"
            },
            {
                "ques": "Explain inheritance concept with an example",
                "ans": "<div><p>Inheritance is one of the fundamental concepts in object-oriented programming, which allows creating a new class (called a child or derived class) from an existing class (called a parent or base class). The derived class inherits all the fields and methods of the base class, and it can also define its own additional fields and methods.</p><p>In Java, inheritance is achieved through the \"extends\" keyword. Let's consider a simple example of inheritance to better understand how it works. Suppose we have a base class called \"Person\" that has a few fields and methods related to a person's basic information, such as name, age, and gender.</p><pre><div><div><code><span>public</span> <span>class</span> <span>Person</span> {<br>    <span>private</span> String name;<br>    <span>private</span> <span>int</span> age;<br>    <span>private</span> String gender;<br><br>    <span>public</span> <span>Person</span><span>(String name, <span>int</span> age, String gender)</span> {<br>        <span>this</span>.name = name;<br>        <span>this</span>.age = age;<br>        <span>this</span>.gender = gender;<br>    }<br><br>    <span>public</span> <span>void</span> <span>display</span><span>()</span> {<br>        System.out.println(<span>\"Name: \"</span> + name);<br>        System.out.println(<span>\"Age: \"</span> + age);<br>        System.out.println(<span>\"Gender: \"</span> + gender);<br>    }<br>}<br></code></div></div></pre><p>Now, let's say we want to create a new class called \"Employee\" that has all the fields and methods of the \"Person\" class, but it also has some additional fields and methods specific to an employee, such as employee ID, job title, and salary. We can achieve this by extending the \"Person\" class and adding new fields and methods to the \"Employee\" class.</p><pre><div><div><code><span>public</span> <span>class</span> <span>Employee</span> <span>extends</span> <span>Person</span> {<br>    <span>private</span> <span>int</span> empId;<br>    <span>private</span> String jobTitle;<br>    <span>private</span> <span>double</span> salary;<br><br>    <span>public</span> <span>Employee</span><span>(String name, <span>int</span> age, String gender, <span>int</span> empId, String jobTitle, <span>double</span> salary)</span> {<br>        <span>super</span>(name, age, gender);<br>        <span>this</span>.empId = empId;<br>        <span>this</span>.jobTitle = jobTitle;<br>        <span>this</span>.salary = salary;<br>    }<br><br>    <span>public</span> <span>void</span> <span>display</span><span>()</span> {<br>        <span>super</span>.display();<br>        System.out.println(<span>\"Employee ID: \"</span> + empId);<br>        System.out.println(<span>\"Job Title: \"</span> + jobTitle);<br>        System.out.println(<span>\"Salary: \"</span> + salary);<br>    }<br>}<br></code></div></div></pre><p>In the \"Employee\" class, we have added three new fields - \"empId\", \"jobTitle\", and \"salary\", and we have also defined a new method called \"display\". The \"display\" method is also present in the \"Person\" class, but we have overridden it in the \"Employee\" class to include the additional fields specific to an employee.</p><p>Now, we can create an object of the \"Employee\" class and call its methods. The object will have access to all the fields and methods of both the \"Person\" and \"Employee\" classes.</p><pre><div><div><code><span>Employee</span> <span>emp</span> <span>=</span> <span>new</span> <span>Employee</span>(<span>\"John Doe\"</span>, <span>35</span>, <span>\"Male\"</span>, <span>1234</span>, <span>\"Software Engineer\"</span>, <span>75000.00</span>);<br>emp.display();<br></code></div></div></pre><p>Output:</p><pre><div><div><code><span>Name:</span> <span>John</span> <span>Doe</span><br><span>Age:</span> <span>35</span><br><span>Gender:</span> <span>Male</span><br><span>Employee ID:</span> <span>1234</span><br><span>Job Title:</span> <span>Software</span> <span>Engineer</span><br><span>Salary:</span> <span>75000.0</span><br></code></div></div></pre><p>In this example, we have demonstrated how inheritance can help in creating a new class with the same fields and methods as an existing class, but with additional features specific to the new class. Inheritance is a powerful concept that allows us to reuse code, increase code maintainability, and make the code more efficient.</p></div>"
            },
            {
                "ques": "What is the difference between collections and ArrayList?",
                "ans": "<div><p>In Java, collections and ArrayList are related concepts, but they are not the same thing. The Collection interface is a high-level interface that defines a set of methods that are implemented by different collection classes. ArrayList is one of the collection classes that implements the List interface, which extends the Collection interface.</p><p>Collections are used to store and manipulate groups of related objects. Collections can be used to store and manipulate objects of any type, including primitive data types. Collections provide methods for adding, removing, and searching for elements. Collections can be used to create complex data structures, such as maps and sets, which can be used to store and manipulate data in a variety of ways.</p><p>ArrayList, on the other hand, is a specific implementation of the List interface, which is a sub-interface of the Collection interface. An ArrayList is a resizable array that can store elements of any type. ArrayList provides methods for adding, removing, and searching for elements in the list. ArrayList can be used to store and manipulate data in a variety of ways, but it is more limited than the Collection interface.</p><p>The main difference between collections and ArrayList is that collections are a more general concept, while ArrayList is a specific implementation of the List interface. Collections can be used to create more complex data structures, while ArrayList is more limited in its functionality.</p><p>Here's an example code snippet that demonstrates the difference between collections and ArrayList:</p><pre><div><div><code>import java.util.*;<br><br><span>public</span> <span>class</span> <span>CollectionVsArrayList</span> {<br>    <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>        <br>        <span>// Create a collection of strings</span><br>        Collection&lt;String&gt; myCollection = <span>new</span> ArrayList&lt;String&gt;();<br>        myCollection.<span>add</span>(<span>\"Hello\"</span>);<br>        myCollection.<span>add</span>(<span>\"World\"</span>);<br>        myCollection.<span>add</span>(<span>\"!\"</span>);<br><br>        <span>// Create an ArrayList of integers</span><br>        List&lt;Integer&gt; myList = <span>new</span> ArrayList&lt;Integer&gt;();<br>        myList.<span>add</span>(<span>1</span>);<br>        myList.<span>add</span>(<span>2</span>);<br>        myList.<span>add</span>(<span>3</span>);<br>        <br>        <span>// Print the elements of the collection</span><br>        <span>for</span> (String s : myCollection) {<br>            System.<span>out</span>.println(s);<br>        }<br><br>        <span>// Print the elements of the ArrayList</span><br>        <span>for</span> (<span>int</span> i : myList) {<br>            System.<span>out</span>.println(i);<br>        }<br>    }<br>}<br></code></div></div></pre><p>In this example, we create a collection of strings and an ArrayList of integers. We add elements to both the collection and the ArrayList, and then we iterate over them using a for-each loop. The output shows that both the collection and the ArrayList can store and retrieve elements, but the ArrayList is more specific in the type of elements it can store (only integers in this case), while the collection can store elements of any type.</p></div>"
            },
            {
                "ques": "Tell me the internal flow of the Set implementation class with one example",
                "ans": "<div><p>In Java, Set is an interface that represents a collection of elements without duplicates. The Set interface extends the Collection interface and defines the behavior of a collection that cannot contain duplicate elements.</p><p>One of the most commonly used implementations of the Set interface is the HashSet class. The HashSet class stores its elements in a hash table, which provides constant-time performance for basic operations such as adding, removing, and searching for elements.</p><p>Here is an example of how the HashSet class works:</p><pre><div><div><code>import java.util.HashSet;<br><br><span>public</span> <span>class</span> <span>HashSetExample</span> {<br>    <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>        <span>// Creating a HashSet</span><br>        HashSet&lt;String&gt; <span>set</span> = <span>new</span> HashSet&lt;String&gt;();<br><br>        <span>// Adding elements to the HashSet</span><br>        <span>set</span>.<span>add</span>(<span>\"Apple\"</span>);<br>        <span>set</span>.<span>add</span>(<span>\"Banana\"</span>);<br>        <span>set</span>.<span>add</span>(<span>\"Orange\"</span>);<br><br>        <span>// Printing the contents of the HashSet</span><br>        System.<span>out</span>.println(<span>\"Contents of HashSet: \"</span> + <span>set</span>);<br><br>        <span>// Adding a duplicate element to the HashSet</span><br>        <span>set</span>.<span>add</span>(<span>\"Banana\"</span>);<br><br>        <span>// Printing the contents of the HashSet</span><br>        System.<span>out</span>.println(<span>\"Contents of HashSet after adding a duplicate element: \"</span> + <span>set</span>);<br><br>        <span>// Removing an element from the HashSet</span><br>        <span>set</span>.<span>remove</span>(<span>\"Orange\"</span>);<br><br>        <span>// Printing the contents of the HashSet</span><br>        System.<span>out</span>.println(<span>\"Contents of HashSet after removing an element: \"</span> + <span>set</span>);<br><br>        <span>// Searching for an element in the HashSet</span><br>        boolean containsBanana = <span>set</span>.contains(<span>\"Banana\"</span>);<br>        System.<span>out</span>.println(<span>\"Does the HashSet contain 'Banana'? \"</span> + containsBanana);<br>    }<br>}<br></code></div></div></pre><p>Output:</p><pre><div><div><code><span>Contents</span> <span>of</span> <span>HashSet</span>: <span>[Banana, Orange, Apple]</span><br><span>Contents</span> <span>of</span> <span>HashSet</span> <span>after</span> <span>adding</span> <span>a</span> <span>duplicate</span> <span>element</span>: <span>[Banana, Orange, Apple]</span><br><span>Contents</span> <span>of</span> <span>HashSet</span> <span>after</span> <span>removing</span> <span>an</span> <span>element</span>: <span>[Banana, Apple]</span><br><span>Does</span> <span>the</span> <span>HashSet</span> <span>contain</span> '<span>Banana</span>'? <span>true</span><br></code></div></div></pre><p>In the above example, we create a HashSet of Strings, add some elements to it, and print its contents. Then, we add a duplicate element to the HashSet, which is not added to the HashSet since it already exists. We then remove an element from the HashSet, and finally, we search for an element in the HashSet using the <code>contains()</code> method.</p><p>The internal flow of the HashSet class is as follows:</p><ul><li>When an element is added to the HashSet using the <code>add()</code> method, the element is hashed using its <code>hashCode()</code> method.</li><li>The hash code is used to determine the bucket in which the element should be stored. A bucket is a linked list of elements that have the same hash code.</li><li>If the bucket is empty, the element is added to the bucket.</li><li>If the bucket is not empty, the linked list is searched to see if the element already exists in the bucket. If the element is not found, it is added to the end of the linked list.</li><li>When an element is removed from the HashSet using the <code>remove()</code> method, the element is hashed using its <code>hashCode()</code> method to determine the bucket in which it is stored.</li><li>The linked list in the bucket is searched to find the element, and if it is found, it is removed from the linked list.</li><li>When an element is searched for using the <code>contains()</code> method, the element is hashed using its <code>hashCode()</code> method to determine the bucket in which it is stored.</li><li>The linked list in the bucket is searched to find the element, and if it is found, the method returns <code>true</code>. If the element is not found, the method returns <code>false</code>.</li></ul><p>In conclusion, the HashSet class provides a fast and efficient way to store and manipulate a collection of elements without duplicates, using a hash table to provide constant-time performance for basic operations.</p></div>"
            },
            {
                "ques": "Where do you use a hashmap?",
                "ans": "<div><p>HashMap is a data structure in Java that stores the data in key-value pairs. It is used to store and manipulate data in an efficient way. HashMap uses a hash function to calculate the index of a key and stores the value at that index. The internal implementation of the HashMap is based on a data structure called a hash table.</p><p>The most common use case of HashMap is when we have a large amount of data and we need to perform quick search operations. Since the search operation is done in constant time (O(1)), HashMap is the most efficient data structure to store this type of data.</p><p>In Selenium automation framework, HashMap is often used to store and manage test data such as test parameters, test configuration data, test results, etc. For example, if we have a set of test data that we want to store and retrieve during our test execution, we can use a HashMap to store the data as key-value pairs. We can then use the keys to retrieve the corresponding values from the HashMap.</p><p>Here's an example of how we can use a HashMap to store and retrieve test data:</p><pre><div><div><code><span>import</span> java.<span>util</span>.<span>HashMap</span>;<br><br><span>public</span> <span>class</span> <span>TestHashMap</span> {<br><br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span><span>String</span>[] args</span>) {<br><br>        <span>// Create a new HashMap to store test data</span><br>        <span>HashMap</span>&lt;<span>String</span>, <span>String</span>&gt; testData = <span>new</span> <span>HashMap</span>&lt;<span>String</span>, <span>String</span>&gt;();<br><br>        <span>// Add some test data to the HashMap</span><br>        testData.<span>put</span>(<span>\"username\"</span>, <span>\"john\"</span>);<br>        testData.<span>put</span>(<span>\"password\"</span>, <span>\"secret\"</span>);<br>        testData.<span>put</span>(<span>\"url\"</span>, <span>\"http://www.example.com\"</span>);<br><br>        <span>// Retrieve test data using keys</span><br>        <span>String</span> username = testData.<span>get</span>(<span>\"username\"</span>);<br>        <span>String</span> password = testData.<span>get</span>(<span>\"password\"</span>);<br>        <span>String</span> url = testData.<span>get</span>(<span>\"url\"</span>);<br><br>        <span>// Print the test data</span><br>        <span>System</span>.<span>out</span>.<span>println</span>(<span>\"Username: \"</span> + username);<br>        <span>System</span>.<span>out</span>.<span>println</span>(<span>\"Password: \"</span> + password);<br>        <span>System</span>.<span>out</span>.<span>println</span>(<span>\"URL: \"</span> + url);<br>    }<br>}<br></code></div></div></pre><p>In the above example, we create a new HashMap object to store our test data. We then add some test data to the HashMap using the <code>put()</code> method. Finally, we retrieve the test data using the keys and print it to the console.</p><p>The output of the above program will be:</p><pre><div><div><code><span>Username: john</span><br><span>Password: secret</span><br><span>URL: http://www.example.com</span><br></code></div></div></pre><p>In conclusion, HashMap is a very useful data structure in Java that is widely used in many programming applications, including Selenium automation framework. It provides an efficient way to store, manage, and retrieve large amounts of data in key-value pairs.</p></div>"
            },
            {
                "ques": "Diff between Array and ArrayList?",
                "ans": "<div><p>Arrays and ArrayList are two types of data structures in Java, used to store and manipulate a collection of elements. While they have some similarities, there are also significant differences between them.</p><ol><li><p>Declaration and Initialization:<br>Arrays have to be declared with their size at the time of initialization, while the ArrayList can be initialized with the number of elements later.</p><p>// Array Declaration and Initialization<br>int[] arr = new int[3];</p><p>// ArrayList Initialization<br>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</p></li><li><p>Size:<br>Arrays are fixed in size and cannot be resized dynamically at runtime. On the other hand, ArrayList can increase or decrease their size dynamically.</p></li><li><p>Type of data they hold:<br>Arrays can hold both primitive and object types. In contrast, the ArrayList can only hold object types.</p></li><li><p>Performance:<br>Arrays have better performance than ArrayList, especially when it comes to accessing elements. This is because the elements are stored in contiguous memory locations, which makes it easy for the CPU to access them. In contrast, the ArrayList elements are not stored in contiguous memory locations, which makes it harder for the CPU to access them.</p></li><li><p>Methods:<br>Arrays have only limited methods, which can be used to manipulate their data. In contrast, the ArrayList has a wide range of methods, which can be used to add, remove, sort, search, and modify the elements.</p></li></ol><p>Here's an example of the difference between arrays and ArrayList:</p><p>// Declaring and initializing an array of integers<br>int[] arr = {1, 2, 3, 4, 5};</p><p>// Declaring and initializing an ArrayList of integers<br>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();<br>list.add(1);<br>list.add(2);<br>list.add(3);<br>list.add(4);<br>list.add(5);</p><p>// Adding a new element to the array<br>// This will throw an ArrayIndexOutOfBoundsException<br>arr[5] = 6;</p><p>// Adding a new element to the ArrayList<br>list.add(6);</p><p>// Printing the size of the array and the ArrayList<br>System.out.println(\"Size of the array: \" + arr.length);<br>System.out.println(\"Size of the ArrayList: \" + list.size());</p><p>In this example, we have declared an array and an ArrayList, both containing the same set of integers. We then tried to add a new element to both of them. However, when we tried to add the element to the array, it threw an ArrayIndexOutOfBoundsException because the array's size was already fixed at the time of initialization. But when we tried to add the element to the ArrayList, it was added successfully, since the ArrayList can dynamically increase its size.</p></div>"
            },
            {
                "ques": "Write a program using exception handling to click on a button.",
                "ans": "<div><p>Sure, here is an example program in Java using exception handling to click on a button:</p><pre><div><div><code><span>import</span> org.openqa.selenium.*;<br><span>import</span> org.openqa.selenium.chrome.ChromeDriver;<br><span>import</span> org.openqa.selenium.support.ui.ExpectedConditions;<br><span>import</span> org.openqa.selenium.support.ui.WebDriverWait;<br><br><span>public</span> <span>class</span> <span>ClickButton</span> {<br>   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>      <span>// set system property for chrome driver</span><br>      System.setProperty(<span>\"webdriver.chrome.driver\"</span>, <span>\"path/to/chromedriver\"</span>);<br><br>      <span>// create a new ChromeDriver instance</span><br>      <span>WebDriver</span> <span>driver</span> <span>=</span> <span>new</span> <span>ChromeDriver</span>();<br><br>      <span>try</span> {<br>         <span>// navigate to website</span><br>         driver.get(<span>\"https://www.example.com\"</span>);<br><br>         <span>// click on button</span><br>         <span>WebElement</span> <span>button</span> <span>=</span> (<span>new</span> <span>WebDriverWait</span>(driver, <span>10</span>))<br>            .until(ExpectedConditions.elementToBeClickable(By.id(<span>\"button-id\"</span>)));<br>         button.click();<br>      } <span>catch</span> (TimeoutException e) {<br>         System.out.println(<span>\"Button is not clickable within 10 seconds\"</span>);<br>      } <span>catch</span> (NoSuchElementException e) {<br>         System.out.println(<span>\"Button element is not found\"</span>);<br>      } <span>finally</span> {<br>         <span>// quit the driver</span><br>         driver.quit();<br>      }<br>   }<br>}<br></code></div></div></pre><p>In this program, we first set the system property for the ChromeDriver and create a new instance of the ChromeDriver. We then use a try-catch block to handle potential exceptions that may occur when clicking on the button.</p><p>We first navigate to a website, and then use a WebDriverWait to wait for the button to be clickable before clicking on it. If the button is not clickable within 10 seconds, a TimeoutException is caught and an error message is printed to the console. Similarly, if the button element is not found, a NoSuchElementException is caught and an error message is printed.</p><p>Finally, we use a finally block to quit the driver and clean up any resources used by the program.</p><p>This program demonstrates how exception handling can be used in Selenium to handle errors that may occur during testing, such as a button not being clickable or a page element not being found.</p></div>"
            },
            {
                "ques": "How to call a function of a class without creating an object?",
                "ans": "<div><p>In Java, it is possible to call a static function of a class without creating an object. This is because the static function belongs to the class and not to any instance of the class. To call a static function, we use the class name followed by the function name.</p><p>Here is an example:</p><pre><div><div><code><span>public</span> <span>class</span> <span>MyClass</span> {<br>  <span><span>public</span> <span>static</span> <span>void</span> <span>myStaticFunction</span>()</span> {<br>    System.<span>out</span>.println(<span>\"Hello from my static function!\"</span>);<br>  }<br>}<br></code></div></div></pre><p>In this example, <code>myStaticFunction()</code> is a static function in the <code>MyClass</code> class. To call this function without creating an object of the class, we use the class name followed by the function name:</p><pre><div><div><code>MyClass<span>.myStaticFunction</span>();<br></code></div></div></pre><p>This will output <code>Hello from my static function!</code>.</p><p>We can also call static variables without creating an object:</p><pre><div><div><code><span>public</span> <span>class</span> <span>MyClass</span> {<br>  <span>public</span> <span>static</span> <span>int</span> myStaticVariable = <span>42</span>;<br>}<br><br>System.<span>out</span>.println(MyClass.myStaticVariable);<br></code></div></div></pre><p>This will output <code>42</code>.</p><p>In general, we use static functions and variables when we want to associate a function or a variable with the class as a whole, rather than with any particular instance of the class. Static functions and variables can be accessed and used by any code that has access to the class.</p></div>"
            },
            {
                "ques": "what is overloading and overriding?",
                "ans": "<div><p>In Java, overloading and overriding are two important concepts related to methods in object-oriented programming. Both of these concepts allow you to define multiple methods with the same name in a class, but they differ in their functionality and usage.</p><p>Overloading:<br>Method overloading is a concept in Java where multiple methods can have the same name but with different parameters. This is useful when you want to perform the same operation but with different input parameters. Java compiler differentiates these methods based on their method signature, which is determined by the method name and the types and order of the parameters.</p><p>Here's an example of method overloading in Java:</p><pre><div><div><code><span>public</span> <span>class</span> <span>MathOperations</span> {<br>  <span>public</span> <span>int</span> <span>add</span><span>(<span>int</span> a, <span>int</span> b)</span> {<br>    <span>return</span> a + b;<br>  }<br><br>  <span>public</span> <span>int</span> <span>add</span><span>(<span>int</span> a, <span>int</span> b, <span>int</span> c)</span> {<br>    <span>return</span> a + b + c;<br>  }<br><br>  <span>public</span> <span>double</span> <span>add</span><span>(<span>double</span> a, <span>double</span> b)</span> {<br>    <span>return</span> a + b;<br>  }<br>}<br></code></div></div></pre><p>In the above example, the <code>MathOperations</code> class contains three methods with the same name \"add\", but with different parameters. The first method takes two integers as input, the second method takes three integers, and the third method takes two doubles. The compiler will determine which method to call based on the number and type of the arguments passed.</p><p>Overriding:<br>Method overriding is a concept in Java where a subclass provides a specific implementation of a method that is already provided by its parent class. This allows you to customize the behavior of a method in the subclass without modifying the implementation of the parent class.</p><p>Here's an example of method overriding in Java:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Animal</span> {<br>  <span><span>public</span> <span>void</span> <span>makeSound</span>()</span> {<br>    System.<span>out</span>.println(<span>\"The animal makes a sound\"</span>);<br>  }<br>}<br><br><span>public</span> <span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span> {<br>  @Override<br>  <span><span>public</span> <span>void</span> <span>makeSound</span>()</span> {<br>    System.<span>out</span>.println(<span>\"The dog barks\"</span>);<br>  }<br>}<br></code></div></div></pre><p>In the above example, the <code>Animal</code> class defines a method called <code>makeSound()</code>, which prints a generic message. The <code>Dog</code> class extends the <code>Animal</code> class and overrides the <code>makeSound()</code> method to provide a specific implementation that prints \"The dog barks\". When an object of the <code>Dog</code> class calls the <code>makeSound()</code> method, the overridden method in the <code>Dog</code> class will be called instead of the one in the <code>Animal</code> class.</p><p>In summary, method overloading allows you to define multiple methods with the same name but different parameters in a class, while method overriding allows you to provide a specific implementation of a method that is already defined in a parent class in a subclass.</p></div>"
            },
            {
                "ques": "Is multiple inheritances is possible in java? Explain with reasons.",
                "ans": "<div><p>Java does not support multiple inheritances. Multiple inheritance is a feature where a class can inherit behaviors and properties from more than one parent class. However, in Java, a class can extend only one class at a time. This design decision was made to prevent certain problems that can arise when using multiple inheritance, such as the \"diamond problem.\"</p><p>The diamond problem is a scenario that can occur in multiple inheritance when two parent classes of a class have a method with the same name and arguments. If the subclass tries to inherit both methods, it can cause ambiguity as to which method it should actually use. Java avoids this problem by not allowing multiple inheritance.</p><p>Instead of multiple inheritance, Java provides the concept of interfaces. An interface is a blueprint of a class that defines a set of methods that a class must implement. In Java, a class can implement multiple interfaces, which allows it to inherit behaviors from multiple sources.</p><p>Here is an example to demonstrate the concept of interfaces:</p><pre><div><div><code><span>interface</span> <span>Vehicle</span> {<br>    <span><span>void</span> <span>start</span>()</span>;<br>    <span><span>void</span> <span>stop</span>()</span>;<br>}<br><br><span>class</span> <span>Car</span> <span>implements</span> <span>Vehicle</span> {<br>    <span><span>public</span> <span>void</span> <span>start</span>()</span> {<br>        System.<span>out</span>.println(<span>\"Car started\"</span>);<br>    }<br>    <br>    <span><span>public</span> <span>void</span> <span>stop</span>()</span> {<br>        System.<span>out</span>.println(<span>\"Car stopped\"</span>);<br>    }<br>}<br><br><span>class</span> <span>Bike</span> <span>implements</span> <span>Vehicle</span> {<br>    <span><span>public</span> <span>void</span> <span>start</span>()</span> {<br>        System.<span>out</span>.println(<span>\"Bike started\"</span>);<br>    }<br>    <br>    <span><span>public</span> <span>void</span> <span>stop</span>()</span> {<br>        System.<span>out</span>.println(<span>\"Bike stopped\"</span>);<br>    }<br>}<br><br><span>public</span> <span>class</span> <span>Main</span> {<br>    <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>        Vehicle v1 = <span>new</span> Car();<br>        Vehicle v2 = <span>new</span> Bike();<br>        <br>        v1.start();<br>        v1.stop();<br>        <br>        v2.start();<br>        v2.stop();<br>    }<br>}<br></code></div></div></pre><p>In this example, we have created an interface called <code>Vehicle</code> that defines two methods: <code>start()</code> and <code>stop()</code>. We have then created two classes <code>Car</code> and <code>Bike</code> that implement the <code>Vehicle</code> interface. These classes have their own implementation of the <code>start()</code> and <code>stop()</code> methods.</p><p>In the <code>main()</code> method, we have created two objects of type <code>Vehicle</code> using the <code>Car</code> and <code>Bike</code> classes. We have then called the <code>start()</code> and <code>stop()</code> methods on these objects. Since both the <code>Car</code> and <code>Bike</code> classes implement the <code>Vehicle</code> interface, they must implement the <code>start()</code> and <code>stop()</code> methods. This allows us to call these methods without worrying about which specific class they belong to.</p><p>In summary, while Java does not support multiple inheritances, it provides the concept of interfaces as a way to inherit behaviors from multiple sources.</p></div>"
            },
            {
                "ques": "What is the use of sleep()?",
                "ans": "<div><p>In Java, <code>Thread.sleep()</code> is a method used to pause the execution of a program for a specified amount of time. This method is commonly used in situations where a program needs to wait for a specific event or process to occur before continuing its execution. The <code>Thread.sleep()</code> method is part of the <code>Thread</code> class and can be used with any thread in a Java program.</p><p>The syntax for using the <code>Thread.sleep()</code> method is as follows:</p><pre><div><div><code><span>try</span> {<br>    Thread.sleep(timeInMilliseconds);<br>} <span>catch</span> (InterruptedException e) {<br>    <span>// handle the exception</span><br>}<br></code></div></div></pre><p>The <code>timeInMilliseconds</code> parameter specifies the amount of time to pause the program in milliseconds. The <code>InterruptedException</code> is a checked exception that can be thrown by the <code>Thread.sleep()</code> method if the thread is interrupted while it is sleeping. It is important to catch this exception and handle it appropriately.</p><p>The <code>Thread.sleep()</code> method is commonly used in test automation to introduce delays between actions in a test script. For example, if a test script needs to wait for a page to load or an AJAX request to complete before continuing, the <code>Thread.sleep()</code> method can be used to pause the script for a specified amount of time.</p><p>Here is an example of using <code>Thread.sleep()</code> in a Selenium test script:</p><pre><div><div><code><span>// navigate to a webpage</span><br>driver.get(<span>\"https://www.example.com\"</span>);<br><br><span>// wait for the page to load</span><br><span>try</span> {<br>    Thread.sleep(<span>5000</span>); <span>// wait for 5 seconds</span><br>} <span>catch</span> (InterruptedException e) {<br>    e.printStackTrace();<br>}<br><br><span>// perform an action on the page</span><br><span>WebElement</span> <span>button</span> <span>=</span> driver.findElement(By.id(<span>\"submit-button\"</span>));<br>button.click();<br></code></div></div></pre><p>In this example, the <code>Thread.sleep()</code> method is used to wait for 5 seconds before clicking a button on the webpage. This delay allows time for the page to fully load and for any necessary scripts or resources to be downloaded before continuing with the test.</p><p>It is important to note that excessive use of <code>Thread.sleep()</code> can lead to slow and inefficient test scripts. In situations where a test script needs to wait for a specific event or condition, it is often better to use a more targeted approach such as explicit waits or conditional statements.</p></div>"
            },
            {
                "ques": "What is data binding.",
                "ans": "<div><p>In software engineering, data binding is a technique to establish a connection between the data model and the user interface. In simpler terms, data binding is the process of binding the data between the front-end and back-end of an application. This process enables developers to establish a synchronization between the UI and the data of the application. Whenever the user interacts with the application, the changes in the UI will be automatically reflected in the data model, and vice versa.</p><p>In Java, data binding can be achieved using different frameworks such as JavaFX, Spring, and Struts. These frameworks provide built-in support for data binding, which makes it easier for developers to implement this feature.</p><p>Here is an example of data binding in JavaFX:</p><p>Suppose we have a simple User model with two attributes, \"name\" and \"age\". We want to bind this model to a UI component so that the UI is updated whenever the model is updated.</p><pre><div><div><code><span>public</span> <span>class</span> <span>User</span> {<br>    <span>private</span> <span>String</span> name;<br>    <span>private</span> int age;<br><br>    <span>public</span> <span>User</span>(<span>String</span> name, int age) {<br>        <span>this</span>.<span>name</span> = name;<br>        <span>this</span>.<span>age</span> = age;<br>    }<br><br>    <span>public</span> <span>String</span> <span>getName</span>(<span></span>) {<br>        <span>return</span> name;<br>    }<br><br>    <span>public</span> <span>void</span> <span>setName</span>(<span><span>String</span> name</span>) {<br>        <span>this</span>.<span>name</span> = name;<br>    }<br><br>    <span>public</span> int <span>getAge</span>(<span></span>) {<br>        <span>return</span> age;<br>    }<br><br>    <span>public</span> <span>void</span> <span>setAge</span>(<span>int age</span>) {<br>        <span>this</span>.<span>age</span> = age;<br>    }<br>}<br></code></div></div></pre><p>We can use the JavaFX framework to bind this model to a UI component, like a text field. Here is an example of how to bind a TextField to the \"name\" attribute of the User model:</p><pre><div><div><code>User user = new <span>User</span>(\"John\", <span>30</span>);<br><br>TextField nameField = new <span>TextField</span>();<br>nameField<span>.textProperty</span>()<span>.bindBidirectional</span>(user.nameProperty());<br></code></div></div></pre><p>In the code above, we first create an instance of the User model with a name and age. Then, we create a TextField and bind its textProperty to the nameProperty of the User model. This establishes a two-way data binding between the UI component and the data model. Whenever the user enters a new value into the text field, the name attribute of the User model is updated, and vice versa.</p><p>In summary, data binding is a powerful technique in software development that enables synchronization between the front-end and back-end of an application. It is useful for building responsive and dynamic user interfaces that automatically update themselves based on changes in the data model.</p></div>"
            },
            {
                "ques": "How to find the broken links on the web page using selenium automation?",
                "ans": "<div><p>Finding and handling broken links is an important part of web application testing using Selenium. Broken links are the links that are not working or pointing to a wrong URL. Selenium provides a powerful set of APIs to interact with web pages, and using those APIs, we can find broken links on the page.</p><p>Here are the steps to find broken links on a web page using Selenium:</p><p>Step 1: Launch the web browser using Selenium WebDriver<br>To launch a web browser using Selenium WebDriver, we need to instantiate a WebDriver object and then use its <code>get()</code> method to open the web page.</p><pre><div><div><code><span>// Import necessary packages</span><br><span>import</span> org.openqa.selenium.By;<br><span>import</span> org.openqa.selenium.WebDriver;<br><span>import</span> org.openqa.selenium.WebElement;<br><span>import</span> org.openqa.selenium.chrome.ChromeDriver;<br><br><span>// Instantiate a WebDriver object</span><br><span>WebDriver</span> <span>driver</span> <span>=</span> <span>new</span> <span>ChromeDriver</span>();<br><br><span>// Open the web page</span><br>driver.get(<span>\"https://www.example.com/\"</span>);<br></code></div></div></pre><p>Step 2: Find all links on the web page<br>To find all links on a web page, we can use the <code>findElements()</code> method provided by Selenium WebDriver. This method returns a list of <code>WebElement</code> objects that match the specified selector.</p><pre><div><div><code><span>// Find all links on the web page</span><br>List&lt;WebElement&gt; links = driver.findElements(By.tagName(<span>\"a\"</span>));<br></code></div></div></pre><p>Step 3: Verify the status of each link<br>To verify the status of each link, we can use the <code>HttpURLConnection</code> class provided by Java. This class can be used to establish a connection with the URL of the link and then retrieve the HTTP response code.</p><pre><div><div><code><span>// Import necessary packages</span><br><span>import</span> java.net.HttpURLConnection;<br><span>import</span> java.net.URL;<br><br><span>// Verify the status of each link</span><br><span>for</span> (WebElement link : links) {<br>    <span>String</span> <span>url</span> <span>=</span> link.getAttribute(<span>\"href\"</span>);<br>    <span>HttpURLConnection</span> <span>connection</span> <span>=</span> (HttpURLConnection) <span>new</span> <span>URL</span>(url).openConnection();<br>    connection.connect();<br>    <span>int</span> <span>responseCode</span> <span>=</span> connection.getResponseCode();<br>    <span>if</span> (responseCode &gt;= <span>400</span>) {<br>        System.out.println(url + <span>\" is a broken link\"</span>);<br>    }<br>}<br></code></div></div></pre><p>In the above code, we are first getting the URL of each link using <code>getAttribute()</code> method and then creating a new <code>HttpURLConnection</code> object. We then establish a connection with the URL using the <code>connect()</code> method and retrieve the HTTP response code using the <code>getResponseCode()</code> method. If the response code is greater than or equal to 400, it means the link is broken.</p><p>Step 4: Close the web browser<br>After completing the test, we need to close the web browser using the <code>close()</code> method provided by Selenium WebDriver.</p><pre><div><div><code><span>// Close the web browser</span><br>driver.close();<br></code></div></div></pre><p>This is how we can find broken links on a web page using Selenium automation.</p></div>"
            },
            {
                "ques": "What are the class and objects?",
                "ans": "<div><p>In Java, a class is a blueprint for creating objects, which are instances of the class. It defines the data and behavior of objects and acts as a template from which objects are created. A class contains fields, which are variables that store data, and methods, which are functions that define the behavior of the class.</p><p>Here is an example of a simple Java class:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Car</span> {<br>    <span>// Fields</span><br>    <span>private</span> String make;<br>    <span>private</span> String model;<br>    <span>private</span> <span>int</span> year;<br><br>    <span>// Constructor</span><br>    <span><span>public</span> <span>Car</span>(<span>String make, String model, <span>int</span> year</span>)</span> {<br>        <span>this</span>.make = make;<br>        <span>this</span>.model = model;<br>        <span>this</span>.year = year;<br>    }<br><br>    <span>// Methods</span><br>    <span><span>public</span> <span>void</span> <span>start</span>()</span> {<br>        System.<span>out</span>.println(<span>\"The \"</span> + year + <span>\" \"</span> + make + <span>\" \"</span> + model + <span>\" is starting.\"</span>);<br>    }<br><br>    <span><span>public</span> <span>void</span> <span>stop</span>()</span> {<br>        System.<span>out</span>.println(<span>\"The \"</span> + year + <span>\" \"</span> + make + <span>\" \"</span> + model + <span>\" is stopping.\"</span>);<br>    }<br>}<br></code></div></div></pre><p>In this example, the <code>Car</code> class has three fields (<code>make</code>, <code>model</code>, and <code>year</code>) and two methods (<code>start</code> and <code>stop</code>). The constructor initializes the fields with the values passed in as arguments.</p><p>An object is an instance of a class. To create an object, you use the <code>new</code> keyword followed by the name of the class and any arguments needed for the constructor. Here's an example:</p><pre><div><div><code><span>Car</span> <span>myCar</span> <span>=</span> <span>new</span> <span>Car</span>(<span>\"Honda\"</span>, <span>\"Civic\"</span>, <span>2021</span>);<br></code></div></div></pre><p>This creates a new <code>Car</code> object with the make \"Honda\", model \"Civic\", and year 2021, and assigns it to the <code>myCar</code> variable.</p><p>Once an object is created, you can call its methods using the dot notation:</p><pre><div><div><code>myCar<span>.start</span>();<br>myCar<span>.stop</span>();<br></code></div></div></pre><p>This will call the <code>start</code> and <code>stop</code> methods of the <code>myCar</code> object, which will print out messages indicating that the car is starting and stopping, respectively.</p><p>In summary, a class defines the structure and behavior of objects, and an object is an instance of a class with its own set of data and methods. By creating multiple objects of the same class, you can have multiple instances of the same behavior with different data.</p></div>"
            },
            {
                "ques": "How you do customize sorting in HashSet.",
                "ans": "<div><p>The HashSet in Java is an implementation of the Set interface and is used to store a collection of elements in no particular order. When we add elements to the HashSet, they are not stored in any particular order, and their ordering might change as we perform operations on them. However, there may be cases where we need to sort the elements of a HashSet in a customized way.</p><p>To achieve customized sorting in HashSet, we can use the TreeSet class, which implements the SortedSet interface. We can create a TreeSet and pass a custom Comparator object to its constructor. The Comparator object provides the logic for sorting the elements.</p><p>Let's consider an example where we have a HashSet of Employee objects, where Employee is a custom class with attributes like id, name, and age. We want to sort the Employee objects based on their age in ascending order.</p><p>First, we need to create a Comparator object that provides the sorting logic. We can create a new class that implements the Comparator interface and overrides the compare method.</p><pre><div><div><code><span>import</span> java.util.Comparator;<br><br><span>public</span> <span>class</span> <span>EmployeeAgeComparator</span> <span>implements</span> <span>Comparator</span>&lt;Employee&gt; {<br><br>    <span>@Override</span><br>    <span>public</span> <span>int</span> <span>compare</span><span>(Employee e1, Employee e2)</span> {<br>        <span>return</span> Integer.compare(e1.getAge(), e2.getAge());<br>    }<br>}<br></code></div></div></pre><p>Here, we are comparing two Employee objects based on their age attribute.</p><p>Next, we can create a HashSet of Employee objects and add some Employee objects to it.</p><pre><div><div><code>Set&lt;Employee&gt; employeeSet = <span>new</span> <span>HashSet</span>&lt;&gt;();<br>employeeSet.add(<span>new</span> <span>Employee</span>(<span>1</span>, <span>\"John\"</span>, <span>25</span>));<br>employeeSet.add(<span>new</span> <span>Employee</span>(<span>2</span>, <span>\"Mary\"</span>, <span>30</span>));<br>employeeSet.add(<span>new</span> <span>Employee</span>(<span>3</span>, <span>\"Bob\"</span>, <span>28</span>));<br></code></div></div></pre><p>To get the elements in the HashSet sorted based on age, we can create a TreeSet object and pass the custom comparator object to its constructor.</p><pre><div><div><code>TreeSet&lt;Employee&gt; sortedSet = <span>new</span> <span>TreeSet</span>&lt;&gt;(<span>new</span> <span>EmployeeAgeComparator</span>());<br>sortedSet.addAll(employeeSet);<br></code></div></div></pre><p>Now, the sortedSet will contain the elements from the employeeSet sorted based on their age.</p><p>We can verify this by iterating over the sortedSet and printing the Employee objects.</p><pre><div><div><code><span>for</span> (Employee employee : sortedSet) {<br>    System.out.println(employee);<br>}<br></code></div></div></pre><p>Output:</p><pre><div><div><code>Employee{<span>id</span>=<span>1</span>, name=<span>'John'</span>, age=<span>25</span>}<br>Employee{<span>id</span>=<span>3</span>, name=<span>'Bob'</span>, age=<span>28</span>}<br>Employee{<span>id</span>=<span>2</span>, name=<span>'Mary'</span>, age=<span>30</span>}<br></code></div></div></pre><p>As we can see, the Employee objects are sorted based on their age in ascending order.</p><p>In this way, we can use a customized sorting logic to sort the elements in a HashSet using the TreeSet class in Java.</p></div>"
            },
            {
                "ques": "Difference between interface and abstract?",
                "ans": "<div><p>In Java, both interfaces and abstract classes are used for abstraction, but they have some differences. Here are the key differences between them:</p><ol><li><p>Implementation: Abstract classes can have both abstract and non-abstract methods, while interfaces can only have abstract methods. An abstract class can provide partial implementation of a class, while an interface is just a contract that defines the methods that must be implemented by a class.</p></li><li><p>Inheritance: A class can extend only one abstract class, but it can implement multiple interfaces. An abstract class can be used to define a base class for a hierarchy, while an interface is used to define a set of methods that a class must implement.</p></li><li><p>Access modifiers: Abstract classes can have public, private, or protected access modifiers for their methods and variables, while all methods and variables in an interface are implicitly public.</p></li><li><p>Constructors: Abstract classes can have constructors, but interfaces cannot.</p></li></ol><p>Example:</p><p>Here is an example of an abstract class and an interface to illustrate their differences:</p><pre><div><div><code><span>abstract</span> <span>class</span> <span>Animal</span> {<br>   <span><span>public</span> <span>void</span> <span>eat</span>()</span> {<br>      System.<span>out</span>.println(<span>\"Eating...\"</span>);<br>   }<br>   <span><span>public</span> <span>abstract</span> <span>void</span> <span>sound</span>()</span>;<br>}<br><br><span>interface</span> <span>Vehicle</span> {<br>   <span><span>void</span> <span>start</span>()</span>;<br>   <span><span>void</span> <span>stop</span>()</span>;<br>}<br></code></div></div></pre><p>In this example, the <code>Animal</code> class is an abstract class that has a concrete implementation of the <code>eat()</code> method, and an abstract method <code>sound()</code> that must be implemented by any class that extends <code>Animal</code>. On the other hand, the <code>Vehicle</code> interface only defines two methods that must be implemented by any class that implements it, without any implementation.</p><p>Overall, both interfaces and abstract classes are useful for abstraction in Java, but they have different use cases and can be used together in many cases.</p></div>"
            },
            {
                "ques": "Diff between String and StringBuffer?",
                "ans": "<div><p>In Java, <code>String</code> and <code>StringBuffer</code> are both classes that represent character sequences, but they have some fundamental differences.</p><p><code>String</code> is an immutable class, which means that its value cannot be changed after it has been created. Any operation on a string results in the creation of a new string. So, for example, if you want to concatenate two strings, the original strings are not modified; instead, a new string is created that contains the concatenation of the original strings.</p><p><code>StringBuffer</code>, on the other hand, is a mutable class that allows you to modify its value without creating a new object. StringBuffer is used when you want to modify strings very often, such as in a loop.</p><p>Here is a table of some key differences between <code>String</code> and <code>StringBuffer</code>:</p><table><thead><tr><th></th><th>String</th><th>StringBuffer</th></tr></thead><tbody><tr><td>Mutability</td><td>Immutable</td><td>Mutable</td></tr><tr><td>Thread-Safe</td><td>Yes</td><td>Yes</td></tr><tr><td>Performance</td><td>Slow for concatenation</td><td>Fast for concatenation and mutation</td></tr><tr><td>Memory Usage</td><td>More memory efficient</td><td>Less memory efficient</td></tr></tbody></table><p>Let's look at some examples to see how they differ:</p><p>Example 1: Concatenation</p><pre><div><div><code><span>String</span> <span>str</span> = <span>\"Hello\"</span>;<br><span>str</span> = <span>str</span> + <span>\" World\"</span>;<br>System.out.<span>println</span>(<span>str</span>);<br></code></div></div></pre><p>Output: \"Hello World\"</p><p>In this example, we have concatenated two strings, but the original <code>str</code> variable is not modified; instead, a new string is created and assigned to <code>str</code>.</p><pre><div><div><code>StringBuffer sb = <span>new</span> StringBuffer(<span>\"Hello\"</span>);<br>sb.<span>append</span>(<span>\" World\"</span>);<br>System.out.<span>println</span>(sb.toString());<br></code></div></div></pre><p>Output: \"Hello World\"</p><p>In this example, we have used a <code>StringBuffer</code> to concatenate two strings. We have modified the original <code>sb</code> object by using the <code>append()</code> method.</p><p>Example 2: Reversing a String</p><pre><div><div><code>String <span>str</span> = <span>\"Hello\"</span>;<br>String <span>reversed</span> = new StringBuilder(<span>str</span>).reverse().toString();<br>System.out.println(<span>reversed</span>);<br></code></div></div></pre><p>Output: \"olleH\"</p><p>In this example, we have reversed a string using a <code>StringBuilder</code> object. We have created a new object, reversed the string, and converted it to a <code>String</code>.</p><pre><div><div><code>StringBuffer sb = new <span>StringBuffer</span>(\"Hello\");<br>sb<span>.reverse</span>();<br>System<span>.out</span><span>.println</span>(sb.toString());<br></code></div></div></pre><p>Output: \"olleH\"</p><p>In this example, we have reversed a string using a <code>StringBuffer</code>. We have modified the original <code>sb</code> object by using the <code>reverse()</code> method.</p><p>In summary, <code>String</code> is immutable and <code>StringBuffer</code> is mutable. <code>String</code> is faster for read-only operations, whereas <code>StringBuffer</code> is faster for operations that require modifications.</p></div>"
            },
            {
                "ques": "How to generate user-defined exceptions, write syntax.",
                "ans": "<div><p>In Java, we can create our own exception classes that extend the predefined Exception class or its subclasses to represent custom exceptions that can occur during the execution of a program. This helps in making the code more modular, reusable, and efficient as it allows us to handle specific exceptions and take appropriate actions based on them.</p><p>To generate user-defined exceptions in Java, we need to create a new class that extends the Exception class or any of its subclasses. We can provide our own implementation of constructors and methods to represent the specific exception that we want to generate.</p><p>Here is an example that demonstrates how to create a custom exception class in Java:</p><pre><div><div><code><span>// Custom exception class</span><br><span>class</span> <span>CustomException</span> <span>extends</span> <span>Exception</span> {<br>    <span>public</span> <span>CustomException</span><span>(String message)</span> {<br>        <span>super</span>(message);<br>    }<br>}<br><br><span>// Class that throws the custom exception</span><br><span>class</span> <span>MyClass</span> {<br>    <span>public</span> <span>void</span> <span>myMethod</span><span>(<span>int</span> num)</span> <span>throws</span> CustomException {<br>        <span>if</span> (num == <span>0</span>) {<br>            <span>throw</span> <span>new</span> <span>CustomException</span>(<span>\"Number cannot be zero\"</span>);<br>        }<br>        <span>else</span> {<br>            System.out.println(<span>\"Number is \"</span> + num);<br>        }<br>    }<br>}<br><br><span>// Main class to test the custom exception</span><br><span>public</span> <span>class</span> <span>CustomExceptionExample</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>        <span>MyClass</span> <span>obj</span> <span>=</span> <span>new</span> <span>MyClass</span>();<br>        <span>try</span> {<br>            obj.myMethod(<span>0</span>);<br>        } <span>catch</span> (CustomException e) {<br>            System.out.println(<span>\"Caught CustomException: \"</span> + e.getMessage());<br>        }<br>    }<br>}<br></code></div></div></pre><p>In this example, we create a custom exception class <code>CustomException</code> that extends the <code>Exception</code> class. We provide a constructor that takes a string message and passes it to the super class constructor.</p><p>We also create a class <code>MyClass</code> that throws the custom exception if the input number is zero. It has a method <code>myMethod</code> that takes an integer argument and throws the <code>CustomException</code> if the number is zero.</p><p>In the main class <code>CustomExceptionExample</code>, we create an object of <code>MyClass</code> and call the <code>myMethod</code> with the input number as zero. Since the number is zero, the custom exception is thrown and caught in the catch block, where we print the message associated with the exception.</p><p>Output:</p><pre><div><div><code><span>Caught</span> <span>CustomException</span>: <span>Number</span> cannot be zero<br></code></div></div></pre><p>In this way, we can generate and handle custom exceptions in Java to make our code more robust and reliable.</p></div>"
            },
            {
                "ques": "Using which keyword we acquire the behavior of one class to another class",
                "ans": "<div><p>In Java, the keyword \"extends\" is used to acquire the behavior of one class to another class. This is the concept of inheritance, where one class can inherit the properties and behaviors of another class. The class that inherits the properties is known as the subclass or derived class, and the class whose properties are inherited is known as the superclass or base class.</p><p>To use the \"extends\" keyword, we define the superclass first, and then we can define the subclass with the keyword \"extends\" followed by the superclass name. This allows the subclass to inherit all the public and protected properties and behaviors of the superclass.</p><p>Here's an example of using the \"extends\" keyword to inherit from a superclass in Java:</p><pre><div><div><code><span>// Defining the superclass</span><br><span>public</span> <span>class</span> <span>Animal</span> {<br>   <span><span>public</span> <span>void</span> <span>makeSound</span>()</span> {<br>      System.<span>out</span>.println(<span>\"Some sound\"</span>);<br>   }<br>}<br><br><span>// Defining the subclass that inherits from Animal</span><br><span>public</span> <span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span> {<br>   <span><span>public</span> <span>void</span> <span>makeSound</span>()</span> {<br>      System.<span>out</span>.println(<span>\"Bark\"</span>);<br>   }<br>}<br><br><span>// Using the classes to create objects and call methods</span><br><span>public</span> <span>class</span> <span>Main</span> {<br>   <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>      Animal myAnimal = <span>new</span> Animal();<br>      Dog myDog = <span>new</span> Dog();<br>      myAnimal.makeSound();<br>      myDog.makeSound();<br>   }<br>}<br></code></div></div></pre><p>In this example, we define the Animal class with a method \"makeSound\". We then define the Dog class with the \"extends\" keyword to inherit from the Animal class. The Dog class overrides the \"makeSound\" method to make a different sound. Finally, in the Main class, we create objects of both classes and call the \"makeSound\" method on each of them.</p><p>The output of the program will be:</p><pre><div><div><code><span>Some</span> sound<br>Bark<br></code></div></div></pre><p>This demonstrates how the \"extends\" keyword is used to acquire the behavior of one class to another class in Java.</p></div>"
            },
            {
                "ques": "Why do we write a string[]args in the main method?",
                "ans": "<div><p>In Java, the <code>main</code> method is the entry point of any program. It is the method that is called when the program is executed, and it is where the program starts its execution. The <code>main</code> method is defined with a specific signature that takes an array of <code>String</code> objects as an argument. The <code>String</code> array is called <code>args</code>, and it allows you to pass arguments to the program when it is launched.</p><p>The reason we include <code>String[] args</code> in the <code>main</code> method is to allow us to pass command line arguments to the program. Command line arguments are input parameters that are passed to the program when it is executed. These arguments are stored as elements of the <code>String</code> array <code>args</code>.</p><p>For example, let's say we want to pass a file name to a program to be processed. We can pass the file name as a command line argument when we run the program. Here is an example of how to do that:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Program</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>        <span>if</span> (args.length &gt; <span>0</span>) {<br>            <span>String</span> <span>fileName</span> <span>=</span> args[<span>0</span>];<br>            <span>// Do something with the file</span><br>            System.out.println(<span>\"File name is: \"</span> + fileName);<br>        } <span>else</span> {<br>            System.out.println(<span>\"No file name specified\"</span>);<br>        }<br>    }<br>}<br></code></div></div></pre><p>In this example, the program takes the first command line argument and stores it in a <code>fileName</code> variable. If no arguments are provided, the program prints a message indicating that no file name was specified.</p><p>By including <code>String[] args</code> in the <code>main</code> method, we are able to pass arguments to the program at runtime and use those arguments to control the program's behavior.</p></div>"
            },
            {
                "ques": "DIfference between this and super?",
                "ans": "<div><p>In Java, <code>this</code> and <code>super</code> are keywords used to refer to different things in a class hierarchy.</p><p>The <code>this</code> keyword refers to the current instance of a class. It is typically used to access or set instance variables, or to call other methods on the same instance. For example, in the following code, <code>this.name</code> refers to the instance variable <code>name</code> of the current object:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Person</span> {<br>    <span>private</span> String name;<br>    <br>    <span><span>public</span> <span>Person</span>(<span>String name</span>)</span> {<br>        <span>this</span>.name = name;<br>    }<br>    <br>    <span><span>public</span> <span>void</span> <span>printName</span>()</span> {<br>        System.<span>out</span>.println(<span>\"My name is \"</span> + <span>this</span>.name);<br>    }<br>}<br></code></div></div></pre><p>The <code>super</code> keyword, on the other hand, refers to the superclass of the current class. It is typically used to call a method or constructor in the superclass, or to access a superclass's instance variables. For example, in the following code, <code>super()</code> is used to call the constructor of the superclass, and <code>super.name</code> is used to access the <code>name</code> instance variable of the superclass:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Student</span> <span>extends</span> <span>Person</span> {<br>    <span>private</span> <span>int</span> id;<br>    <br>    <span>public</span> <span>Student</span><span>(String name, <span>int</span> id)</span> {<br>        <span>super</span>(name);<br>        <span>this</span>.id = id;<br>    }<br>    <br>    <span>public</span> <span>void</span> <span>printInfo</span><span>()</span> {<br>        <span>super</span>.printName();<br>        System.out.println(<span>\"My student ID is \"</span> + <span>this</span>.id);<br>    }<br>}<br></code></div></div></pre><p>In summary, <code>this</code> is used to refer to the current instance of a class, while <code>super</code> is used to refer to the superclass of a class.</p></div>"
            },
            {
                "ques": "How many ways we can create a thread and which one best approach and why?",
                "ans": "<div><p>In Java, there are two ways to create a thread: extending the <code>Thread</code> class and implementing the <code>Runnable</code> interface. The <code>Thread</code> class provides the functionality of creating and managing threads while the <code>Runnable</code> interface provides a way to run code in a thread.</p><ol><li>Extending Thread Class:<br>We can create a thread by extending the <code>Thread</code> class and overriding the <code>run()</code> method. Then, we can create an instance of our class and call the <code>start()</code> method to start the thread. This is not recommended as we are not able to extend any other class.</li></ol><p>Example:</p><pre><div><div><code><span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> {<br>    <span>public</span> <span>void</span> <span>run</span><span>()</span> {<br>        System.out.println(<span>\"MyThread running\"</span>);<br>    }<br>}<br><br><span>MyThread</span> <span>thread</span> <span>=</span> <span>new</span> <span>MyThread</span>();<br>thread.start();<br></code></div></div></pre><ol start=\"2\"><li>Implementing Runnable interface:<br>We can create a thread by implementing the <code>Runnable</code> interface and overriding the <code>run()</code> method. Then, we can create an instance of <code>Thread</code> class and pass the instance of our class as a parameter to the constructor of <code>Thread</code>. Then we can call the <code>start()</code> method to start the thread.</li></ol><p>Example:</p><pre><div><div><code><span>class</span> <span>MyRunnable</span> <span>implements</span> <span>Runnable</span> {<br>    <span>public</span> <span>void</span> <span>run</span><span>()</span> {<br>        System.out.println(<span>\"MyRunnable running\"</span>);<br>    }<br>}<br><br><span>MyRunnable</span> <span>myRunnable</span> <span>=</span> <span>new</span> <span>MyRunnable</span>();<br><span>Thread</span> <span>thread</span> <span>=</span> <span>new</span> <span>Thread</span>(myRunnable);<br>thread.start();<br></code></div></div></pre><p>The second approach is the best practice in creating threads because we can extend any other class and also because of its flexibility in implementing multi-threading.</p><p>We can also use <code>ExecutorService</code> and <code>Callable</code> to create a thread, but it is more complicated and requires more code. It is not recommended for small applications.</p><p>In summary, implementing the <code>Runnable</code> interface is the best approach to creating threads in Java because it provides more flexibility and extensibility.</p></div>"
            },
            {
                "ques": "What are Abstract class and Interface? Difference b/w them?",
                "ans": "<div><p>In Java, both abstract classes and interfaces provide mechanisms for defining and enforcing a set of rules that a class must follow. However, there are some key differences between the two.</p><p>Abstract class is a class that cannot be instantiated. It is meant to be subclassed, so that concrete subclasses can be created from it. An abstract class may contain abstract methods, which are declared but not implemented. Abstract methods are meant to be implemented by subclasses. Here's an example of an abstract class:</p><pre><div><div><code><span>public</span> <span>abstract</span> <span>class</span> <span>Shape</span> {<br>    <span><span>public</span> <span>abstract</span> <span>double</span> <span>getArea</span>()</span>;<br>}<br></code></div></div></pre><p>On the other hand, an interface is a contract that specifies a set of methods that a class must implement. An interface may not contain any implementation. Here's an example of an interface:</p><pre><div><div><code><span>public</span> <span>interface</span> <span>Drawable</span> {<br>    <span><span>void</span> <span>draw</span>()</span>;<br>}<br></code></div></div></pre><p>The key difference between the two is that a class can implement multiple interfaces, but can only extend one abstract class. Another difference is that an abstract class can contain non-abstract methods, but an interface can only contain method signatures. Finally, an abstract class can have instance variables, while an interface cannot.</p><p>When to use an abstract class vs. an interface depends on the specific needs of the application. If you need to provide a default implementation for some methods, then an abstract class is a better choice. If you need to provide a set of methods that can be implemented by multiple classes, then an interface is a better choice.</p><p>In summary, an abstract class is a class that cannot be instantiated and can contain abstract methods with implementation for some methods, while an interface is a contract that specifies a set of methods that a class must implement and can not contain any implementation.</p></div>"
            },
            {
                "ques": "Write Swapping of numbers program in Java.",
                "ans": "<div><p>Swapping of numbers is a common programming problem. In this problem, we have to swap the values of two variables. For example, if we have two variables A and B with values 10 and 20, respectively, we want to swap their values so that A becomes 20 and B becomes 10.</p><p>There are many ways to solve this problem in Java. One of the simplest ways is to use a temporary variable to store the value of one of the variables before swapping. Here's an example program that demonstrates this approach:</p><pre><div><div><code><span>public</span> <span>class</span> <span>SwapNumbers</span> {<br>    <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>        <span>int</span> a = <span>10</span>;<br>        <span>int</span> b = <span>20</span>;<br>        <span>int</span> temp;<br><br>        System.<span>out</span>.println(<span>\"Before swapping: a = \"</span> + a + <span>\", b = \"</span> + b);<br><br>        <span>// Swap the values of a and b</span><br>        temp = a;<br>        a = b;<br>        b = temp;<br><br>        System.<span>out</span>.println(<span>\"After swapping: a = \"</span> + a + <span>\", b = \"</span> + b);<br>    }<br>}<br></code></div></div></pre><p>In this program, we first declare two variables <code>a</code> and <code>b</code> and assign them the values 10 and 20, respectively. We also declare a temporary variable <code>temp</code>. Then, we print the values of <code>a</code> and <code>b</code> before swapping.</p><p>Next, we swap the values of <code>a</code> and <code>b</code> using the temporary variable <code>temp</code>. We assign the value of <code>a</code> to <code>temp</code>, then assign the value of <code>b</code> to <code>a</code>, and finally assign the value of <code>temp</code> to <code>b</code>. This effectively swaps the values of <code>a</code> and <code>b</code>.</p><p>Finally, we print the values of <code>a</code> and <code>b</code> after swapping. The output of this program will be:</p><pre><div><div><code><span>Before</span> <span>swapping</span>: <span>a</span> = <span>10</span>, <span>b</span> = <span>20</span><br><span>After</span> <span>swapping</span>: <span>a</span> = <span>20</span>, <span>b</span> = <span>10</span><br></code></div></div></pre><p>This is a simple and effective way to swap the values of two variables in Java.</p></div>"
            },
            {
                "ques": "What are the types of inheritance in java?",
                "ans": "<div><p>In Java, inheritance is a mechanism that allows a class to inherit the properties and behavior of another class. The class that is being inherited from is called the superclass, and the class that is inheriting the properties and behavior is called the subclass.</p><p>There are four types of inheritance in Java:</p><ol><li>Single inheritance: In single inheritance, a subclass extends a single superclass. The superclass can be any class, including an abstract class. The subclass inherits all the properties and methods of the superclass.</li></ol><p>Example:</p><pre><div><div><code><span>class</span> <span>Superclass</span> {<br>    <span><span>public</span> <span>void</span> <span>method</span>()</span> {<br>        System.<span>out</span>.println(<span>\"This is a superclass method.\"</span>);<br>    }<br>}<br><br><span>class</span> <span>Subclass</span> <span>extends</span> <span>Superclass</span> {<br>    <span><span>public</span> <span>void</span> <span>method2</span>()</span> {<br>        System.<span>out</span>.println(<span>\"This is a subclass method.\"</span>);<br>    }<br>}<br><br><span>// Creating object of subclass and calling its methods</span><br>Subclass s = <span>new</span> Subclass();<br>s.method(); <span>// This is a superclass method.</span><br>s.method2(); <span>// This is a subclass method.</span><br></code></div></div></pre><ol start=\"2\"><li>Multilevel inheritance: In multilevel inheritance, a subclass extends a superclass that is also a subclass of another class. This creates a parent-child relationship between the classes.</li></ol><p>Example:</p><pre><div><div><code><span>class</span> <span>Superclass</span> {<br>    <span><span>public</span> <span>void</span> <span>method</span>()</span> {<br>        System.<span>out</span>.println(<span>\"This is a superclass method.\"</span>);<br>    }<br>}<br><br><span>class</span> <span>Subclass</span> <span>extends</span> <span>Superclass</span> {<br>    <span><span>public</span> <span>void</span> <span>method2</span>()</span> {<br>        System.<span>out</span>.println(<span>\"This is a subclass method.\"</span>);<br>    }<br>}<br><br><span>class</span> <span>Subsubclass</span> <span>extends</span> <span>Subclass</span> {<br>    <span><span>public</span> <span>void</span> <span>method3</span>()</span> {<br>        System.<span>out</span>.println(<span>\"This is a subsubclass method.\"</span>);<br>    }<br>}<br><br><span>// Creating object of subsubclass and calling its methods</span><br>Subsubclass s = <span>new</span> Subsubclass();<br>s.method(); <span>// This is a superclass method.</span><br>s.method2(); <span>// This is a subclass method.</span><br>s.method3(); <span>// This is a subsubclass method.</span><br></code></div></div></pre><ol start=\"3\"><li>Hierarchical inheritance: In hierarchical inheritance, multiple subclasses extend the same superclass. This creates a parent-child relationship between the superclass and each of the subclasses.</li></ol><p>Example:</p><pre><div><div><code><span>class</span> <span>Superclass</span> {<br>    <span><span>public</span> <span>void</span> <span>method</span>()</span> {<br>        System.<span>out</span>.println(<span>\"This is a superclass method.\"</span>);<br>    }<br>}<br><br><span>class</span> <span>Subclass1</span> <span>extends</span> <span>Superclass</span> {<br>    <span><span>public</span> <span>void</span> <span>method1</span>()</span> {<br>        System.<span>out</span>.println(<span>\"This is a subclass1 method.\"</span>);<br>    }<br>}<br><br><span>class</span> <span>Subclass2</span> <span>extends</span> <span>Superclass</span> {<br>    <span><span>public</span> <span>void</span> <span>method2</span>()</span> {<br>        System.<span>out</span>.println(<span>\"This is a subclass2 method.\"</span>);<br>    }<br>}<br><br><span>// Creating object of subclass1 and subclass2 and calling their methods</span><br>Subclass1 s1 = <span>new</span> Subclass1();<br>s1.method(); <span>// This is a superclass method.</span><br>s1.method1(); <span>// This is a subclass1 method.</span><br><br>Subclass2 s2 = <span>new</span> Subclass2();<br>s2.method(); <span>// This is a superclass method.</span><br>s2.method2(); <span>// This is a subclass2 method.</span><br></code></div></div></pre><ol start=\"4\"><li>Multiple inheritance (not supported in Java): Multiple inheritance is a mechanism where a subclass can inherit properties and behavior from multiple superclasses. Java does not support multiple inheritance to avoid the diamond problem, where multiple superclasses have the same method and the compiler cannot decide which method to call.</li></ol><p>In summary, Java supports single inheritance, multilevel inheritance, and hierarchical inheritance. Multiple inheritance is not supported in Java to avoid the diamond problem.</p></div>"
            },
            {
                "ques": "How do you compare the local image and image on the webpage page using selenium java?",
                "ans": "<div><p>In Selenium with Java, we can compare a local image and the image on a web page using the ImageIO and BufferedImage classes. We can capture the screenshot of the web page using the TakesScreenshot interface and store it in a BufferedImage object. Then, we can load the local image and compare it with the captured image using the ImageIO class.</p><p>Here's an example program that demonstrates how to compare a local image and an image on a web page:</p><pre><div><div><code><span>import</span> java.awt.image.BufferedImage;<br><span>import</span> java.io.File;<br><span>import</span> java.io.IOException;<br><span>import</span> javax.imageio.ImageIO;<br><span>import</span> org.openqa.selenium.By;<br><span>import</span> org.openqa.selenium.OutputType;<br><span>import</span> org.openqa.selenium.TakesScreenshot;<br><span>import</span> org.openqa.selenium.WebDriver;<br><span>import</span> org.openqa.selenium.chrome.ChromeDriver;<br><br><span>public</span> <span>class</span> <span>ImageComparisonExample</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> <span>throws</span> IOException {<br>        <span>// Set the system property for Chrome driver</span><br>        System.setProperty(<span>\"webdriver.chrome.driver\"</span>, <span>\"path/to/chromedriver\"</span>);<br><br>        <span>// Create an instance of ChromeDriver</span><br>        <span>WebDriver</span> <span>driver</span> <span>=</span> <span>new</span> <span>ChromeDriver</span>();<br><br>        <span>// Navigate to the web page</span><br>        driver.get(<span>\"https://www.example.com\"</span>);<br><br>        <span>// Capture the screenshot of the web page</span><br>        <span>File</span> <span>screenshot</span> <span>=</span> ((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE);<br>        <span>BufferedImage</span> <span>capturedImage</span> <span>=</span> ImageIO.read(screenshot);<br><br>        <span>// Load the local image</span><br>        <span>File</span> <span>localImage</span> <span>=</span> <span>new</span> <span>File</span>(<span>\"path/to/local/image.png\"</span>);<br>        <span>BufferedImage</span> <span>expectedImage</span> <span>=</span> ImageIO.read(localImage);<br><br>        <span>// Compare the images</span><br>        <span>boolean</span> <span>isImagesEqual</span> <span>=</span> <span>true</span>;<br>        <span>if</span> (capturedImage.getWidth() == expectedImage.getWidth() &amp;&amp; capturedImage.getHeight() == expectedImage.getHeight()) {<br>            <span>for</span> (<span>int</span> <span>x</span> <span>=</span> <span>0</span>; x &lt; capturedImage.getWidth(); x++) {<br>                <span>for</span> (<span>int</span> <span>y</span> <span>=</span> <span>0</span>; y &lt; capturedImage.getHeight(); y++) {<br>                    <span>if</span> (capturedImage.getRGB(x, y) != expectedImage.getRGB(x, y)) {<br>                        isImagesEqual = <span>false</span>;<br>                        <span>break</span>;<br>                    }<br>                }<br>            }<br>        } <span>else</span> {<br>            isImagesEqual = <span>false</span>;<br>        }<br><br>        <span>// Print the result</span><br>        <span>if</span> (isImagesEqual) {<br>            System.out.println(<span>\"Images are equal\"</span>);<br>        } <span>else</span> {<br>            System.out.println(<span>\"Images are not equal\"</span>);<br>        }<br><br>        <span>// Close the browser</span><br>        driver.quit();<br>    }<br>}<br></code></div></div></pre><p>In this program, we first set the system property for the Chrome driver and create an instance of the ChromeDriver. Then, we navigate to the web page and capture the screenshot of the web page using the getScreenshotAs() method of the TakesScreenshot interface. We store the captured image in a BufferedImage object.</p><p>Next, we load the local image and store it in a BufferedImage object using the ImageIO class. We then compare the two images pixel by pixel using nested loops. If the images are equal, we set the <code>isImagesEqual</code> flag to true; otherwise, we set it to false.</p><p>Finally, we print the result and close the browser.</p><p>Note that this method of image comparison is not always reliable as small changes in the web page can lead to differences in the captured image. It's best to use it as a preliminary check and not the sole method of image verification.</p></div>"
            },
            {
                "ques": "What are the different types of polymorphism?",
                "ans": "<div><p>Polymorphism is a feature in object-oriented programming that allows objects of different types to be treated as if they are of the same type. There are two types of polymorphism: static polymorphism and dynamic polymorphism. In Java, static polymorphism is achieved through method overloading, while dynamic polymorphism is achieved through method overriding.</p><ol><li><p>Static Polymorphism:<br>Static polymorphism is also known as compile-time polymorphism. It allows us to use the same method name with different parameters in the same class. The compiler resolves the method calls during the compile-time. The method overloading is an example of static polymorphism.</p><p>Example of Method Overloading:</p><p>public class StaticPolymorphism {<br>public void sum(int a, int b) {<br>System.out.println(a+b);<br>}<br>public void sum(int a, int b, int c) {<br>System.out.println(a+b+c);<br>}<br>public static void main(String args[]) {<br>StaticPolymorphism obj = new StaticPolymorphism();<br>obj.sum(10, 20);<br>obj.sum(10, 20, 30);<br>}<br>}</p><p>Output:<br>30<br>60</p></li><li><p>Dynamic Polymorphism:<br>Dynamic Polymorphism is also known as runtime polymorphism. It allows us to call a method of a subclass using a reference variable of a superclass. In dynamic polymorphism, the method is resolved during runtime. Dynamic Polymorphism is achieved through method overriding.</p><p>Example of Method Overriding:</p><p>class Animal {<br>public void sound() {<br>System.out.println(\"Animal is making a sound\");<br>}<br>}<br>class Dog extends Animal {<br>public void sound() {<br>System.out.println(\"Dog is barking\");<br>}<br>}<br>public class DynamicPolymorphism {<br>public static void main(String args[]) {<br>Animal obj = new Dog();<br>obj.sound();<br>}<br>}</p><p>Output:<br>Dog is barking</p></li></ol><p>In summary, Polymorphism is a very important concept in object-oriented programming that allows you to write flexible, reusable, and extensible code. Static Polymorphism achieved through method overloading, while Dynamic Polymorphism achieved through method overriding.</p></div>"
            },
            {
                "ques": "Difference between String and StringBuffer?",
                "ans": "<div><p>In Java, the <code>String</code> and <code>StringBuffer</code> are two classes that are used to store and manipulate text-based data. Although they both serve a similar purpose, they are quite different in their implementation and usage.</p><p><code>String</code> is an immutable class, meaning that once an object of <code>String</code> class is created, it cannot be modified. If we try to modify it, a new object is created. <code>String</code> is a final class in Java, so we cannot extend or modify its functionality. <code>String</code> objects are stored in the String constant pool, which is a special area of heap memory reserved for storing string literals. When we create a string object, if another string object with the same value already exists in the constant pool, the new object will not be created, but the reference of the existing object will be returned.</p><p>On the other hand, <code>StringBuffer</code> is a mutable class, which means that it can be modified after creation. We can append, insert, or delete characters from a <code>StringBuffer</code> object without creating a new object. <code>StringBuffer</code> is not a final class, so we can extend or modify its functionality as per our requirements.</p><p>Here is an example that demonstrates the difference between <code>String</code> and <code>StringBuffer</code>:</p><pre><div><div><code><span>public</span> <span>class</span> <span>StringVsStringBuffer</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>        <span>String</span> <span>str</span> <span>=</span> <span>\"Hello\"</span>;<br>        str.concat(<span>\" World\"</span>);<br>        System.out.println(<span>\"String value after concatenation: \"</span> + str);  <span>// Output: Hello</span><br><br>        <span>StringBuffer</span> <span>strBuf</span> <span>=</span> <span>new</span> <span>StringBuffer</span>(<span>\"Hello\"</span>);<br>        strBuf.append(<span>\" World\"</span>);<br>        System.out.println(<span>\"StringBuffer value after concatenation: \"</span> + strBuf); <span>// Output: HelloWorld</span><br>    }<br>}<br></code></div></div></pre><p>In the above example, we create a <code>String</code> object and a <code>StringBuffer</code> object with the same initial value. Then, we try to concatenate another string to each of them. In the case of the <code>String</code> object, we use the <code>concat()</code> method, which returns a new string and does not modify the original string. In contrast, we use the <code>append()</code> method of <code>StringBuffer</code>, which modifies the original object by appending the new string to it. As a result, the value of the <code>String</code> object remains the same, while the value of the <code>StringBuffer</code> object changes.</p></div>"
            },
            {
                "ques": "Will findelements throw an error when the element is not found?",
                "ans": "<div><p>Yes, the <code>findElements</code> method of Selenium WebDriver throws an error when the element is not found. When the <code>findElements</code> method is called, it tries to locate the elements on the web page based on the provided locator strategy. If the element is not found, the <code>findElements</code> method will return an empty list.</p><p>Here's an example code snippet:</p><pre><div><div><code>List&lt;WebElement&gt; elementList = driver.findElements(By.xpath(<span>\"//input[@name='username']\"</span>));<br><span>if</span> (elementList.size() == <span>0</span>) {<br>    System.out.<span>println</span>(<span>\"Element not found!\"</span>);<br>} <span>else</span> {<br>    System.out.<span>println</span>(<span>\"Element found!\"</span>);<br>}<br></code></div></div></pre><p>In the above code, we are trying to locate an input element with the name attribute set to 'username' using an XPath locator strategy. If the element is not found, the <code>findElements</code> method will return an empty list, which we can check using the <code>size()</code> method. If the size of the list is zero, we can assume that the element was not found and display an appropriate error message.</p><p>Alternatively, we can use the <code>findElement</code> method, which throws an exception when the element is not found. In this case, we can use a <code>try-catch</code> block to handle the exception:</p><pre><div><div><code><span>try</span> {<br>    WebElement element = driver.findElement(By.xpath(<span>\"//input[@name='username']\"</span>));<br>    System.<span>out</span>.println(<span>\"Element found!\"</span>);<br>} <span>catch</span> (NoSuchElementException e) {<br>    System.<span>out</span>.println(<span>\"Element not found!\"</span>);<br>}<br></code></div></div></pre><p>In the above code, we are using the <code>findElement</code> method to locate the input element. If the element is not found, a <code>NoSuchElementException</code> is thrown, which we can catch using a <code>try-catch</code> block and display an appropriate error message.</p></div>"
            },
            {
                "ques": "Difference in selenium versions 2, 3 and 4? What are new features added?",
                "ans": "<div><p>Selenium is an open-source web automation testing tool that is widely used for testing web applications across multiple browsers and platforms. The different versions of Selenium are 2, 3, and 4. Each version has its own features and improvements.</p><p>Selenium 2 (Selenium WebDriver) was released in 2011 and introduced a new way of writing Selenium tests using the WebDriver API. WebDriver provides a more modern and stable way of interacting with web browsers. Some of the key features of Selenium 2 include:</p><ul><li>Cross-browser compatibility</li><li>Improved browser automation performance</li><li>Support for headless browser testing</li></ul><p>Selenium 3 was released in 2016 with many new features and improvements. Some of the key features of Selenium 3 include:</p><ul><li>Support for the latest versions of Firefox and Chrome</li><li>Native support for Safari on macOS</li><li>Support for the new Microsoft Edge browser</li></ul><p>Selenium 4 is the latest version of Selenium that was released in 2020. Some of the key features of Selenium 4 include:</p><ul><li>Improved W3C compliance and better browser support</li><li>New and improved Selenium IDE</li><li>Improved error handling and reporting</li><li>Support for mobile testing using Appium</li></ul><p>In addition to the above features, Selenium 4 also provides improved relative locators, which make it easier to locate web elements using different attributes such as position, text, and size.</p><p>Overall, Selenium has come a long way since its initial release, with each new version adding more features and improvements. Selenium 4 is currently the most feature-rich and stable version of Selenium and is recommended for most web testing projects.</p></div>"
            },
            {
                "ques": "What is the problem with thread.sleep in selenium automation code?",
                "ans": "<div><p>In Selenium automation testing, <code>Thread.sleep()</code> is a method that is used to pause the execution of the test script for a specified period of time. However, using <code>Thread.sleep()</code> in Selenium automation code can cause several problems:</p><ol><li><p>Inaccurate Wait Times: When using <code>Thread.sleep()</code>, the script is paused for a fixed amount of time, regardless of whether the element has loaded or not. This can result in inaccurate wait times and may cause the test script to fail.</p></li><li><p>Slows down Test Execution: Using <code>Thread.sleep()</code> can cause the test script to take longer to execute, which can slow down the overall testing process.</p></li><li><p>Not Dynamic: <code>Thread.sleep()</code> is not dynamic and cannot adapt to changes in the web page, such as slow-loading elements. This can cause the test script to fail if the page takes longer to load than the sleep time.</p></li></ol><p>Instead of using <code>Thread.sleep()</code>, it is recommended to use implicit or explicit waits in Selenium automation code. Implicit waits are applied globally and wait for a certain amount of time before throwing a <code>NoSuchElementException</code> exception. Explicit waits are applied to specific elements and wait for the element to load before proceeding with the script.</p><p>Here is an example of using implicit wait in Selenium:</p><pre><div><div><code>WebDriver driver = new <span>ChromeDriver</span>();<br>driver<span>.manage</span>()<span>.timeouts</span>()<span>.implicitlyWait</span>(<span>10</span>, TimeUnit.SECONDS);<br></code></div></div></pre><p>In this example, the <code>implicitlyWait()</code> method waits for 10 seconds before throwing a <code>NoSuchElementException</code> exception.</p><p>Overall, using <code>Thread.sleep()</code> in Selenium automation code can cause several problems and should be avoided. Instead, it is recommended to use implicit or explicit waits for accurate and dynamic wait times.</p></div>"
            },
            {
                "ques": "Difference between while and do-while?",
                "ans": "<div><p>In Java, both the <code>while</code> and <code>do-while</code> loops are used for iteration, but they have some differences in their execution and usage.</p><p>The <code>while</code> loop executes the block of code repeatedly as long as the condition remains true. It first checks the condition before executing the block of code. If the condition is true, it enters the loop and executes the code, and if the condition is false, it skips the loop and moves to the next statement in the program. Here's an example of a <code>while</code> loop:</p><pre><div><div><code>int <span>i</span> = <span>0</span>;<br>while (<span>i</span> &lt; <span>5</span>) {<br>    System<span>.out</span><span>.println</span>(<span>i</span>);<br>    <span>i</span>++;<br>}<br></code></div></div></pre><p>In the above example, the loop will execute five times and print the values from 0 to 4.</p><p>The <code>do-while</code> loop, on the other hand, also executes the block of code repeatedly, but it first executes the block of code once and then checks the condition. If the condition is true, it continues to execute the code, and if the condition is false, it exits the loop. Here's an example of a <code>do-while</code> loop:</p><pre><div><div><code><span>int</span> i = <span>0</span>;<br><span>do</span> {<br>    System.<span>out</span>.println(i);<br>    i++;<br>} <span>while</span> (i &lt; <span>5</span>);<br></code></div></div></pre><p>In the above example, the loop will also execute five times and print the values from 0 to 4, just like the <code>while</code> loop.</p><p>The main difference between <code>while</code> and <code>do-while</code> loops is that the <code>do-while</code> loop always executes the code block at least once, even if the condition is initially false. This is because the condition is checked after the first execution of the code block.</p><p>In general, the <code>while</code> loop is used when the number of iterations is not known in advance and the loop may</p></div>"
            },
            {
                "ques": "What is the difference between length and length() in Java?",
                "ans": "<div><p>In Java, <code>length</code> is an attribute of an array that represents the number of elements in the array, while <code>length()</code> is a method of the <code>String</code> class that returns the length of a string.</p><p>The <code>length</code> attribute of an array can be used to determine the number of elements in the array. Here is an example:</p><pre><div><div><code><span>int</span>[] numbers = {<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>};<br><span>int</span> size = numbers.length;<br>System.out.<span>println</span>(size);<br></code></div></div></pre><p>Output:</p><pre><div><div><code>5<br></code></div></div></pre><p>The <code>length()</code> method of the <code>String</code> class can be used to get the length of a string. Here is an example:</p><pre><div><div><code>String <span>str</span> = <span>\"Hello, world!\"</span>;<br><span>int</span> length = <span>str</span>.length();<br>System.out.println(length);<br></code></div></div></pre><p>Output:</p><pre><div><div><code>13<br></code></div></div></pre><p>It's important to note that <code>length</code> is an attribute and <code>length()</code> is a method. Therefore, when working with arrays, <code>length</code> is used without parentheses, while <code>length()</code> is used with parentheses when working with strings.</p><p>In summary, <code>length</code> is an attribute of an array that represents the number of elements in the array, while <code>length()</code> is a method of the <code>String</code> class that returns the length of a string.</p></div>"
            },
            {
                "ques": "Difference between Map and Set",
                "ans": "<div><p>In Java, Map and Set are two commonly used interfaces that allow storing and retrieving data in a structured way. While both of them are used to store a collection of objects, they differ in the way the data is stored and accessed.</p><p>Map:<br>A Map is a key-value pair based data structure that maps unique keys to corresponding values. It allows you to store and access data based on a unique key, which could be any object. The implementation classes of the Map interface in Java are HashMap, TreeMap, LinkedHashMap, and Hashtable. Here's an example:</p><pre><div><div><code>Map&lt;String, String&gt; <span>map</span> = <span>new</span> HashMap&lt;&gt;();<br><span>map</span>.put(<span>\"key1\"</span>, <span>\"value1\"</span>);<br><span>map</span>.put(<span>\"key2\"</span>, <span>\"value2\"</span>);<br>String value = <span>map</span>.get(<span>\"key1\"</span>);<br>System.out.<span>println</span>(value); <span>// Output: value1</span><br></code></div></div></pre><p>In the example above, we have created a map using the HashMap implementation, and stored two key-value pairs in it. We have then retrieved the value for the key \"key1\" using the get() method.</p><p>Set:<br>A Set is a collection of unique elements that does not allow duplicates. It is implemented by the HashSet, TreeSet, and LinkedHashSet classes. Here's an example:</p><pre><div><div><code>Set&lt;String&gt; <span>set</span> = <span>new</span> HashSet&lt;&gt;();<br><span>set</span>.<span>add</span>(<span>\"element1\"</span>);<br><span>set</span>.<span>add</span>(<span>\"element2\"</span>);<br><span>set</span>.<span>add</span>(<span>\"element3\"</span>);<br><span>set</span>.<span>add</span>(<span>\"element2\"</span>);<br>System.<span>out</span>.println(<span>set</span>); <span>// Output: [element1, element2, element3]</span><br></code></div></div></pre><p>In the example above, we have created a set using the HashSet implementation, and added four elements to it. As the second \"element2\" is a duplicate, it is not added to the set.</p><p>Difference between Map and Set:</p><ol><li>Key-Value Pair: Map is a key-value pair based data structure whereas Set is a collection of unique elements without any specific ordering.</li><li>Duplication: Map allows duplicate values but the keys should be unique whereas Set does not allow any duplicates at all.</li><li>Access: In Map, the elements are accessed based on keys whereas in Set, the elements are accessed based on their index (in case of List Set) or an internal hash code (in case of HashSet).</li></ol></div>"
            },
            {
                "ques": "Can we write [] in front like []a for declaring array?",
                "ans": "<div><p>In Java, we can declare an array by specifying the data type followed by square brackets. The number inside the square brackets specifies the size of the array. For example, int[] myArray = new int[5] creates an integer array with a size of 5.</p><p>However, we can also place the square brackets in front of the variable name to declare an array. For example, we can declare an integer array of size 5 using the syntax int a[] = new int[5];. This syntax is also valid in Java.</p><p>Both the syntaxes can be used to declare an array in Java, but it's considered a best practice to use the first syntax, which is data type followed by square brackets, to declare an array in Java. The second syntax is supported in Java only for backward compatibility with C and C++.</p><p>We can also initialize the array while declaring it using the curly braces {}. For example, int[] myArray = {1, 2, 3, 4, 5}; is equivalent to int myArray[] = {1, 2, 3, 4, 5};.</p><p>Let's see an example of declaring and initializing an array using both syntaxes:</p><pre><div><div><code><span>// Declaring an array using the first syntax</span><br><span>int</span>[] array1 = <span>new</span> <span>int</span>[<span>5</span>];<br><br><span>// Declaring an array using the second syntax</span><br><span>int</span> array2[] = <span>new</span> <span>int</span>[<span>5</span>];<br><br><span>// Initializing the array using curly braces</span><br><span>int</span>[] array3 = {<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>};<br><br><span>// Accessing array elements</span><br>System.out.<span>println</span>(array1[<span>0</span>]); <span>// Output: 0</span><br>System.out.<span>println</span>(array2[<span>1</span>]); <span>// Output: 0</span><br>System.out.<span>println</span>(array3[<span>2</span>]); <span>// Output: 3</span><br></code></div></div></pre><p>In conclusion, both <code>[]a</code> and <code>a[]</code> are valid syntaxes to declare an array in Java, but using <code>dataType[] arrayName</code> is considered the best practice.</p></div>"
            },
            {
                "ques": "Why Set&lt;iterator&gt; is used for handling window Handles&lt;iterator&gt; ?",
                "ans": "<div><p>In Selenium, window handling is a common task that allows the automation test script to navigate to different windows or tabs during the execution of the test cases. The <code>Set</code> interface in Java is used to implement a collection that cannot contain duplicate elements, whereas the <code>Iterator</code> interface is used to traverse a collection and manipulate the elements of the collection.</p><p>When we execute a Selenium script, each new window or tab opened during the execution of the script gets a unique window handle, which is a unique identifier to identify that particular window or tab. We can use this window handle to switch the control to that particular window or tab.</p><p>To handle multiple windows or tabs in Selenium, we use <code>Set&lt;String&gt;</code> to store all the window handles, and then use an <code>Iterator</code> to iterate through all the window handles. We can perform operations like switching between windows, closing windows, and retrieving the window title, using the <code>getWindowHandle()</code>, <code>getWindowHandles()</code>, <code>switchTo().window()</code>, and <code>close()</code> methods.</p><p>Here is an example code to retrieve all the window handles and switch between them:</p><pre><div><div><code><span>// Launch the URL and maximize the window</span><br>driver<span>.get</span>(\"https://www.example.com/\");<br>driver<span>.manage</span>()<span>.window</span>()<span>.maximize</span>();<br><br><span>// Store all the window handles in a Set</span><br>Set&lt;String&gt; windowHandles = driver<span>.getWindowHandles</span>();<br><br><span>// Iterate through the window handles using an iterator</span><br>Iterator&lt;String&gt; iterator = windowHandles<span>.iterator</span>();<br>while (iterator.hasNext()) {<br>    <span>// Get the window handle</span><br>    String handle = iterator<span>.next</span>();<br><br>    <span>// Switch the control to the window using the window handle</span><br>    driver<span>.switchTo</span>()<span>.window</span>(handle);<br><br>    <span>// Print the title of the window</span><br>    System<span>.out</span><span>.println</span>(driver.getTitle());<br><br>    <span>// Close the current window</span><br>    driver<span>.close</span>();<br>}<br></code></div></div></pre><p>In the above code, we first launch the URL and maximize the window. Then, we retrieve all the window handles using <code>getWindowHandles()</code> and store them in a <code>Set</code>. We then use an <code>Iterator</code> to iterate through all the window handles and switch the control to each window using <code>switchTo().window()</code>. Finally, we print the title of the window and close it using the <code>getTitle()</code> and <code>close()</code> methods.</p></div>"
            },
            {
                "ques": "How to synchronize collection classes?",
                "ans": "<div><p>In Java, Collection classes are used to store a group of objects in a single unit. However, if multiple threads are accessing the same collection, it can lead to issues like ConcurrentModificationException or Inconsistent results. To avoid such issues, we can synchronize collection classes to make them thread-safe.</p><p>Synchronization means that only one thread can access the collection at a time. When one thread is accessing a synchronized collection, other threads have to wait until the first thread is done. We can synchronize collection classes in two ways:</p><ol><li>Synchronized keyword:<br>We can use the synchronized keyword to make the collection thread-safe. Here, we need to make sure that every thread that wants to access the collection must acquire the object's lock before accessing the collection.</li></ol><p>For example, let's say we have an ArrayList that we want to synchronize:</p><pre><div><div><code>List&lt;String&gt; list = <span>new</span> ArrayList&lt;String&gt;();<br>list.<span>add</span>(<span>\"one\"</span>);<br>list.<span>add</span>(<span>\"two\"</span>);<br>list.<span>add</span>(<span>\"three\"</span>);<br></code></div></div></pre><p>We can synchronize it using the synchronized keyword as follows:</p><pre><div><div><code><span>List</span>&lt;<span>String</span>&gt; syncList = <span>Collections</span>.<span>synchronizedList</span>(list);<br></code></div></div></pre><p>Now, if multiple threads try to access the <code>syncList</code> simultaneously, only one thread can access it at a time.</p><ol start=\"2\"><li>Concurrent collections:<br>Java provides several concurrent collection classes that are thread-safe, such as ConcurrentHashMap, ConcurrentSkipListMap, and ConcurrentSkipListSet. These classes are designed to handle concurrent access to the collection, and multiple threads can access them simultaneously without any issues.</li></ol><p>For example, let's say we have a HashMap that we want to synchronize:</p><pre><div><div><code><span>Map</span>&lt;<span>String</span>, <span>String</span>&gt; map = <span>new</span> <span>HashMap</span>&lt;<span>String</span>, <span>String</span>&gt;();<br>map.<span>put</span>(<span>\"one\"</span>, <span>\"1\"</span>);<br>map.<span>put</span>(<span>\"two\"</span>, <span>\"2\"</span>);<br>map.<span>put</span>(<span>\"three\"</span>, <span>\"3\"</span>);<br></code></div></div></pre><p>We can use ConcurrentHashMap to synchronize it as follows:</p><pre><div><div><code><span>Map</span>&lt;<span>String</span>, <span>String</span>&gt; syncMap = <span>new</span> <span>ConcurrentHashMap</span>&lt;<span>String</span>, <span>String</span>&gt;(map);<br></code></div></div></pre><p>Now, if multiple threads try to access the <code>syncMap</code> simultaneously, there will be no issues as it is a thread-safe collection.</p><p>In conclusion, we can synchronize collection classes using either the synchronized keyword or the concurrent collection classes to make them thread-safe.</p></div>"
            },
            {
                "ques": "What is the difference between String, String buffer and String Builder?",
                "ans": "<div><p>In Java, Strings are a sequence of characters that are immutable, meaning that once created, they cannot be changed. On the other hand, StringBuffer and StringBuilder are mutable sequence of characters and can be changed after their creation.</p><p>String:<br>In Java, strings are created using the String class. Since String is immutable, if any changes are made to a string, a new String object will be created with the modified value. This can cause a lot of unnecessary overhead in memory usage and performance. Example:</p><pre><div><div><code><span>String</span> <span>str</span> = <span>\"Hello\"</span>; <br><span>str</span> = <span>str</span> + <span>\" World\"</span>; <span>// creates a new object</span><br>System.out.<span>println</span>(<span>str</span>);<br></code></div></div></pre><p>StringBuffer:<br>StringBuffer is a mutable sequence of characters that can be modified after creation. It is useful when we want to modify the string frequently. Example:</p><pre><div><div><code>StringBuffer sb = <span>new</span> StringBuffer(<span>\"Hello\"</span>); <br>sb.<span>append</span>(<span>\" World\"</span>); <span>// modifies the existing object</span><br>System.out.<span>println</span>(sb);<br></code></div></div></pre><p>StringBuilder:<br>StringBuilder is similar to StringBuffer but is not thread-safe. It is faster than StringBuffer in most cases because it does not have the overhead of being thread-safe. Example:</p><pre><div><div><code>StringBuilder sb = <span>new</span> StringBuilder(<span>\"Hello\"</span>); <br>sb.<span>append</span>(<span>\" World\"</span>); <span>// modifies the existing object</span><br>System.out.<span>println</span>(sb);<br></code></div></div></pre><p>In summary, if we need a sequence of characters that is not going to change frequently, we should use String. If we need a mutable sequence of characters and thread-safety is not a concern, we should use StringBuilder. If we need a mutable sequence of characters and thread-safety is a concern, we should use StringBuffer.</p></div>"
            },
            {
                "ques": "Is multi-level inheritance is possible in java? give reason.",
                "ans": "<div><p>Yes, multi-level inheritance is possible in Java, and it allows a subclass to inherit the properties of the superclass and also to become the superclass for another subclass. In this way, a chain of inheritance is created between classes.</p><p>For example, consider the following code:</p><pre><div><div><code><span>class</span> <span>Animal</span> {<br>  <span><span>void</span> <span>display</span>()</span> {<br>    System.<span>out</span>.println(<span>\"I am an animal\"</span>);<br>  }<br>}<br><br><span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span> {<br>  <span><span>void</span> <span>bark</span>()</span> {<br>    System.<span>out</span>.println(<span>\"I can bark\"</span>);<br>  }<br>}<br><br><span>class</span> <span>Labrador</span> <span>extends</span> <span>Dog</span> {<br>  <span><span>void</span> <span>color</span>()</span> {<br>    System.<span>out</span>.println(<span>\"My color is black\"</span>);<br>  }<br>}<br><br><span>public</span> <span>class</span> <span>Main</span> {<br>  <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>    Labrador l = <span>new</span> Labrador();<br>    l.display();<br>    l.bark();<br>    l.color();<br>  }<br>}<br></code></div></div></pre><p>In this example, the <code>Animal</code> class is the superclass for the <code>Dog</code> class, and the <code>Dog</code> class is the superclass for the <code>Labrador</code> class. The <code>Labrador</code> class inherits the properties of both the <code>Animal</code> and <code>Dog</code> classes. The <code>display()</code> method is defined in the <code>Animal</code> class and is inherited by the <code>Dog</code> and <code>Labrador</code> classes, while the <code>bark()</code> method is defined in the <code>Dog</code> class and is inherited by the <code>Labrador</code> class. Finally, the <code>color()</code> method is defined in the <code>Labrador</code> class.</p><p>When the program is executed, the output will be:</p><pre><div><div><code><span>I</span> am an animal<br><span>I</span> can bark<br>My <span>color</span> is black<br></code></div></div></pre><p>In conclusion, multi-level inheritance is possible in Java, and it can be useful in creating a hierarchy of classes where each subclass has its own specific properties and behaviors while also inheriting the properties and behaviors of its superclass.</p></div>"
            },
            {
                "ques": "What is the difference between static and instance variables?",
                "ans": "<div><p>In Java, variables can be categorized as static or instance variables based on their scope and lifespan. Here are the differences between the two:</p><ol><li><p>Scope: Instance variables are specific to a particular instance of a class and can be accessed using the instance of the class. On the other hand, static variables are shared by all instances of the class and can be accessed using the class name.</p></li><li><p>Memory allocation: Each instance of a class has its own copy of instance variables, and they are allocated memory at the time of object creation. In contrast, static variables are allocated memory when the class is loaded into memory and exist throughout the life of the program.</p></li><li><p>Initialization: Instance variables are initialized when an object of the class is created, while static variables are initialized when the class is loaded into memory.</p></li><li><p>Access: Instance variables can be accessed using the object reference of the class, whereas static variables can be accessed directly using the class name.</p></li></ol><p>Here is an example that demonstrates the difference between static and instance variables:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Example</span> {<br>  <span>// instance variable</span><br>  <span>int</span> num = <span>10</span>;<br><br>  <span>// static variable</span><br>  <span>static</span> <span>int</span> count = <span>0</span>;<br><br>  <span><span>public</span> <span>void</span> <span>increment</span>()</span> {<br>    num++;<br>    count++;<br>  }<br><br>  <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>    Example obj1 = <span>new</span> Example();<br>    Example obj2 = <span>new</span> Example();<br><br>    obj1.increment();<br>    obj2.increment();<br><br>    System.<span>out</span>.println(<span>\"Obj1 num: \"</span> + obj1.num); <span>// output: 11</span><br>    System.<span>out</span>.println(<span>\"Obj2 num: \"</span> + obj2.num); <span>// output: 11</span><br>    System.<span>out</span>.println(<span>\"Static count: \"</span> + count); <span>// output: 2</span><br>  }<br>}<br></code></div></div></pre><p>In this example, the <code>Example</code> class has an instance variable <code>num</code> and a static variable <code>count</code>. When two instances of the class <code>obj1</code> and <code>obj2</code> are created, the <code>increment</code> method is called on each object, which increments the value of the instance variable <code>num</code> and the static variable <code>count</code>. When we print the value of <code>num</code> for both objects, we get the value of 11, which is the result of incrementing the initial value of 10 by one on each object. However, when we print the value of <code>count</code>, we get the value of 2, which is the result of incrementing the static variable twice. This demonstrates how the instance and static variables differ in terms of their scope and lifespan.</p></div>"
            },
            {
                "ques": "What is the use of sleep() method in Java?",
                "ans": "<div><p>In Java, the <code>sleep()</code> method is used to pause the execution of a thread for a specified amount of time. The syntax of the sleep method is as follows:</p><pre><div><div><code><span>public</span> <span>static</span> <span>void</span> <span>sleep</span><span>(<span>long</span> millis)</span> <span>throws</span> InterruptedException<br></code></div></div></pre><p>Here, <code>millis</code> is the amount of time to sleep in milliseconds. The <code>sleep()</code> method can be called on any thread and will cause that thread to pause for the specified amount of time.</p><p>The <code>sleep()</code> method is commonly used in situations where we want to pause the execution of a thread for a certain period of time. For example, we can use the <code>sleep()</code> method to introduce a delay between actions in an automated test, to simulate a loading screen or to simulate a long-running operation.</p><p>Here is an example that uses the <code>sleep()</code> method to pause the execution of a thread for 1 second:</p><pre><div><div><code><span>public</span> <span>class</span> <span>SleepExample</span> {<br>    <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>        <span>try</span> {<br>            System.<span>out</span>.println(<span>\"Starting task...\"</span>);<br>            Thread.sleep(<span>1000</span>); <span>// sleep for 1 second</span><br>            System.<span>out</span>.println(<span>\"Task completed.\"</span>);<br>        } <span>catch</span> (InterruptedException e) {<br>            <span>// handle the exception</span><br>        }<br>    }<br>}<br></code></div></div></pre><p>When we run the above code, it will print \"Starting task...\", pause for 1 second, and then print \"Task completed.\".</p><p>It's important to note that the <code>sleep()</code> method can throw an <code>InterruptedException</code> if the thread is interrupted while sleeping. It's a good practice to handle this exception properly to avoid unexpected behavior in our program.</p></div>"
            },
            {
                "ques": "Difference between Default and Protected ketwords.",
                "ans": "<div><p>In Java, <code>default</code> and <code>protected</code> are two access modifiers that determine the visibility and accessibility of classes, methods, and variables. The <code>default</code> access modifier, which is also known as package-private, restricts the access to within the package only. On the other hand, the <code>protected</code> access modifier grants access to the class itself, its subclasses, and other classes within the same package.</p><p>To understand the difference between <code>default</code> and <code>protected</code> access modifiers, let's consider the following example:</p><pre><div><div><code><span>package</span> com.example;<br><br><span>public</span> <span>class</span> <span>Person</span> {<br>    String name;         <span>//default access modifier</span><br>    <span>protected</span> <span>int</span> age;   <span>//protected access modifier</span><br>    <br>    <span>void</span> <span>display</span><span>()</span> {<br>        System.out.println(<span>\"Name: \"</span> + name);<br>        System.out.println(<span>\"Age: \"</span> + age);<br>    }<br>}<br><br><span>package</span> com.example;<br><br><span>public</span> <span>class</span> <span>Student</span> <span>extends</span> <span>Person</span> {<br>    <span>void</span> <span>show</span><span>()</span> {<br>        System.out.println(<span>\"Name: \"</span> + name);<br>        System.out.println(<span>\"Age: \"</span> + age);<br>    }<br>}<br><br><span>package</span> com.example;<br><br><span>public</span> <span>class</span> <span>Main</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>        <span>Person</span> <span>p</span> <span>=</span> <span>new</span> <span>Person</span>();<br>        p.name = <span>\"John\"</span>;<br>        p.age = <span>25</span>;   <span>//error</span><br>        <br>        <span>Student</span> <span>s</span> <span>=</span> <span>new</span> <span>Student</span>();<br>        s.name = <span>\"Alice\"</span>;   <span>//error</span><br>        s.age = <span>20</span>;<br>        s.show();<br>    }<br>}<br></code></div></div></pre><p>In the above example, we have two classes, <code>Person</code> and <code>Student</code>, that are in the same package. The <code>Person</code> class has two instance variables, <code>name</code> and <code>age</code>, with <code>default</code> and <code>protected</code> access modifiers, respectively. The <code>Student</code> class extends the <code>Person</code> class and uses the <code>name</code> and <code>age</code> variables. Finally, we have the <code>Main</code> class that creates objects of <code>Person</code> and <code>Student</code> classes and tries to access the <code>name</code> and <code>age</code> variables.</p><p>As <code>name</code> variable is <code>default</code> access modifier, it is only accessible within the same package, so both the <code>Person</code> and <code>Student</code> classes can access it. However, the <code>age</code> variable is <code>protected</code> access modifier, so it is accessible to the <code>Person</code> and its subclasses, but not directly to the <code>Main</code> class. In the <code>Main</code> class, the <code>name</code> variable is accessible, but the <code>age</code> variable is not.</p><p>In summary, the main difference between <code>default</code> and <code>protected</code> access modifiers is the visibility of the variables and methods. <code>default</code> access modifier makes the variables and methods visible within the package, while <code>protected</code> access modifier allows visibility to the class itself, its subclasses, and the other classes in the same package.</p></div>"
            },
            {
                "ques": "Where to use Comparable and where to use Comparator? Where can we use these in automation project?",
                "ans": "<div><p>In Java, <code>Comparable</code> and <code>Comparator</code> are two interfaces used for sorting objects. Both interfaces provide a way to compare and sort objects in a collection. However, they are used in different scenarios.</p><p><code>Comparable</code> is an interface that defines the natural order of an object. This means that if a class implements <code>Comparable</code>, it can be compared with another object of the same class, and the result will be based on the comparison logic defined in the class. For example, consider a <code>Student</code> class with attributes <code>id</code> and <code>name</code>. If we want to sort a list of <code>Student</code> objects by their <code>id</code>, we can implement <code>Comparable</code> interface in the <code>Student</code> class and define the comparison logic in the <code>compareTo()</code> method.</p><pre><div><div><code><span>public</span> <span>class</span> <span>Student</span> <span>implements</span> <span>Comparable</span>&lt;Student&gt; {<br>    <span>private</span> <span>int</span> id;<br>    <span>private</span> String name;<br><br>    <span>public</span> <span>int</span> <span>compareTo</span><span>(Student s)</span> {<br>        <span>return</span> <span>this</span>.id - s.id;<br>    }<br>    <span>// getters and setters</span><br>}<br></code></div></div></pre><p><code>Comparator</code> is an interface that provides a way to sort objects in a different way than their natural order. This is useful when we want to sort objects based on a different attribute or a custom comparison logic. For example, consider the same <code>Student</code> class as above. If we want to sort the list of <code>Student</code> objects by their <code>name</code>, we can implement <code>Comparator</code> interface in a separate class and define the comparison logic in the <code>compare()</code> method.</p><pre><div><div><code><span>public</span> <span>class</span> <span>StudentNameComparator</span> <span>implements</span> <span>Comparator</span>&lt;Student&gt; {<br>    <span>public</span> <span>int</span> <span>compare</span><span>(Student s1, Student s2)</span> {<br>        <span>return</span> s1.getName().compareTo(s2.getName());<br>    }<br>}<br></code></div></div></pre><p>We can use <code>Comparable</code> when we want to sort objects based on their natural order, i.e., the order defined in the class. <code>Comparator</code> is used when we want to sort objects based on a different attribute or a custom comparison logic.</p><p>In automation projects, we can use <code>Comparable</code> and <code>Comparator</code> to sort collections of objects such as web elements, test results, logs, etc., in a specific order. For example, we can use <code>Comparator</code> to sort a list of web elements by their text, tag name, or any other attribute, in order to perform actions on them in a specific order. Similarly, we can use <code>Comparable</code> to sort a list of test results by their status, execution time, or any other attribute, to display the results in a specific order.</p></div>"
            },
            {
                "ques": "What is data binding?",
                "ans": "<div><p>Data binding is a technique in software development that connects data sources to user interfaces. It enables synchronization between the data and the UI elements, and updates the data in the data source as changes are made in the UI, and vice versa.</p><p>In Java, data binding is often used in frameworks like JavaFX and Spring, which provides an implementation of data binding. JavaFX provides a feature called \"properties\" which is used to bind data to UI elements. With JavaFX properties, any change in the value of a variable is automatically reflected in the UI.</p><p>Here's an example of data binding in JavaFX:</p><pre><div><div><code><span>// Create a String property</span><br><span>StringProperty</span> <span>name</span> <span>=</span> <span>new</span> <span>SimpleStringProperty</span>(<span>\"John\"</span>);<br><br><span>// Create a label and bind it to the name property</span><br><span>Label</span> <span>nameLabel</span> <span>=</span> <span>new</span> <span>Label</span>();<br>nameLabel.textProperty().bind(name);<br><br><span>// Change the name property and see the label update</span><br>name.set(<span>\"Jane\"</span>);<br></code></div></div></pre><p>In this example, we create a String property <code>name</code> and initialize it to \"John\". We then create a label <code>nameLabel</code> and bind its text property to the <code>name</code> property. Finally, we change the <code>name</code> property to \"Jane\", and the label updates automatically.</p><p>Data binding helps reduce the amount of boilerplate code required to manually update the UI in response to changes in the data source. By using data binding, developers can focus on writing business logic without worrying about keeping the UI in sync with the data.</p></div>"
            },
            {
                "ques": "Explain method overloading and overriding with an example",
                "ans": "<div><p>In Java, method overloading and overriding are two important concepts that are used to achieve polymorphism, a fundamental concept in object-oriented programming. Both concepts enable multiple methods to have the same name, but they differ in their implementation and behavior.</p><p>Method overloading is a technique where multiple methods can have the same name but different parameters. Java uses the type and the number of arguments to differentiate between overloaded methods. Here's an example of method overloading:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Calculator</span> {<br>    <span>public</span> <span>int</span> <span>add</span><span>(<span>int</span> a, <span>int</span> b)</span> {<br>        <span>return</span> a + b;<br>    }<br><br>    <span>public</span> <span>int</span> <span>add</span><span>(<span>int</span> a, <span>int</span> b, <span>int</span> c)</span> {<br>        <span>return</span> a + b + c;<br>    }<br>}<br></code></div></div></pre><p>In the above example, we have two methods with the same name <code>add</code>, but they differ in the number of arguments they take. When we call the <code>add</code> method with two arguments, the first method will be executed. When we call it with three arguments, the second method will be executed.</p><p>Method overriding, on the other hand, is a technique where a subclass provides its own implementation of a method that is already present in its parent class. The method in the subclass must have the same name, return type, and parameters as the method in the parent class. Here's an example:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Animal</span> {<br>    <span><span>public</span> <span>void</span> <span>makeSound</span>()</span> {<br>        System.<span>out</span>.println(<span>\"The animal makes a sound\"</span>);<br>    }<br>}<br><br><span>public</span> <span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span> {<br>    @Override<br>    <span><span>public</span> <span>void</span> <span>makeSound</span>()</span> {<br>        System.<span>out</span>.println(<span>\"The dog barks\"</span>);<br>    }<br>}<br></code></div></div></pre><p>In the above example, the <code>Dog</code> class extends the <code>Animal</code> class and overrides the <code>makeSound</code> method. When we call the <code>makeSound</code> method on an object of the <code>Dog</code> class, it will execute the implementation provided in the <code>Dog</code> class.</p><p>Method overloading and overriding can be used in automation projects to create more readable and maintainable code. Method overloading can be used to provide a different way to call a method based on the number and types of arguments. Method overriding can be used to provide a specific implementation for a method in a subclass that is different from the implementation in its parent class.</p></div>"
            },
            {
                "ques": "What is the difference between hashmap and linked hash map?",
                "ans": "<div><p>In Java, <code>HashMap</code> and <code>LinkedHashMap</code> are two common implementations of the <code>Map</code> interface, which stores key-value pairs. While both are used to store elements in the form of key-value pairs, they differ in the way they maintain their elements.</p><p>A <code>HashMap</code> uses a hash table to store and retrieve elements. It does not maintain any order of its elements, and the order of the elements is not guaranteed to be consistent. Retrieval of elements in a <code>HashMap</code> is very fast as it uses the hash code of the key to determine the index of the element in the table.</p><p>On the other hand, a <code>LinkedHashMap</code> is similar to <code>HashMap</code>, but it maintains the order of the elements in which they were inserted. The order is maintained by a doubly-linked list, which keeps track of the order in which the elements were inserted. Therefore, when iterating through a <code>LinkedHashMap</code>, the order of the elements is guaranteed to be the same as the order in which they were inserted.</p><p>Here's an example that demonstrates the difference between <code>HashMap</code> and <code>LinkedHashMap</code>:</p><pre><div><div><code><span>import</span> java.util.HashMap;<br><span>import</span> java.util.LinkedHashMap;<br><span>import</span> java.util.Map;<br><br><span>public</span> <span>class</span> <span>HashMapVsLinkedHashMapExample</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>        <span>// Creating a HashMap</span><br>        Map&lt;String, Integer&gt; hashMap = <span>new</span> <span>HashMap</span>&lt;&gt;();<br><br>        <span>// Adding elements to the HashMap</span><br>        hashMap.put(<span>\"John\"</span>, <span>23</span>);<br>        hashMap.put(<span>\"David\"</span>, <span>42</span>);<br>        hashMap.put(<span>\"Peter\"</span>, <span>34</span>);<br>        hashMap.put(<span>\"Lisa\"</span>, <span>27</span>);<br>        hashMap.put(<span>\"Jack\"</span>, <span>29</span>);<br><br>        <span>// Printing the elements in the HashMap</span><br>        System.out.println(<span>\"HashMap:\"</span>);<br>        <span>for</span> (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet()) {<br>            System.out.println(entry.getKey() + <span>\" - \"</span> + entry.getValue());<br>        }<br><br>        <span>// Creating a LinkedHashMap</span><br>        Map&lt;String, Integer&gt; linkedHashMap = <span>new</span> <span>LinkedHashMap</span>&lt;&gt;();<br><br>        <span>// Adding elements to the LinkedHashMap</span><br>        linkedHashMap.put(<span>\"John\"</span>, <span>23</span>);<br>        linkedHashMap.put(<span>\"David\"</span>, <span>42</span>);<br>        linkedHashMap.put(<span>\"Peter\"</span>, <span>34</span>);<br>        linkedHashMap.put(<span>\"Lisa\"</span>, <span>27</span>);<br>        linkedHashMap.put(<span>\"Jack\"</span>, <span>29</span>);<br><br>        <span>// Printing the elements in the LinkedHashMap</span><br>        System.out.println(<span>\"LinkedHashMap:\"</span>);<br>        <span>for</span> (Map.Entry&lt;String, Integer&gt; entry : linkedHashMap.entrySet()) {<br>            System.out.println(entry.getKey() + <span>\" - \"</span> + entry.getValue());<br>        }<br>    }<br>}<br></code></div></div></pre><p>In the above example, we create a <code>HashMap</code> and add elements to it. We then print the elements, which are not in any particular order. We then create a <code>LinkedHashMap</code>, add the same elements to it, and print the elements. Here, we can see that the elements are printed in the same order in which they were inserted.</p><p>In general, if the order of the elements is important, a <code>LinkedHashMap</code> is a better choice. Otherwise, a <code>HashMap</code> is more efficient in terms of memory usage and performance. In automation projects, both can be used depending on the requirements of the project.</p></div>"
            },
            {
                "ques": "How to perform parameterization in testNG?",
                "ans": "<div><p>Parameterization in TestNG is a useful feature that allows us to run the same test case with different sets of data. This is particularly useful when we want to test a specific functionality with multiple inputs or scenarios. TestNG provides several ways to perform parameterization in tests, including using the <code>@Parameters</code> annotation or a data provider method.</p><p>To perform parameterization in TestNG using the <code>@Parameters</code> annotation, we need to define the parameters in the <code>testng.xml</code> file and annotate the test method with the <code>@Parameters</code> annotation. Here's an example:</p><p>First, we need to define the parameters in the <code>testng.xml</code> file:</p><pre><div><div><code><span><span>&lt;<span>parameter</span> <span>name</span>=<span>\"username\"</span> <span>value</span>=<span>\"user1\"</span> /&gt;</span><br><span>&lt;<span>parameter</span> <span>name</span>=<span>\"password\"</span> <span>value</span>=<span>\"pass1\"</span> /&gt;</span><br></span></code></div></div></pre><p>Then, we annotate the test method with the <code>@Parameters</code> annotation and specify the names of the parameters as arguments:</p><pre><div><div><code><span>@Test</span><br><span>@Parameters</span>({<span>\"username\"</span>, <span>\"password\"</span>})<br>public void <span>testLogin</span>(String username, String password) {<br>    <span>// perform login using the provided username and password</span><br>}<br></code></div></div></pre><p>TestNG will automatically inject the values of the parameters from the <code>testng.xml</code> file into the test method.</p><p>Another way to perform parameterization in TestNG is by using a data provider method. A data provider method is a method that returns a two-dimensional array of objects, where each row represents a set of test data. Here's an example:</p><pre><div><div><code><span>@DataProvider</span>(name = <span>\"loginData\"</span>)<br><span>public</span> <span>Object</span>[][] <span>getLoginData</span>(<span></span>) {<br>    <span>return</span> <span>new</span> <span>Object</span>[][] {{<span>\"user1\"</span>, <span>\"pass1\"</span>}, {<span>\"user2\"</span>, <span>\"pass2\"</span>}};<br>}<br><br><span>@Test</span>(dataProvider = <span>\"loginData\"</span>)<br><span>public</span> <span>void</span> <span>testLogin</span>(<span><span>String</span> username, <span>String</span> password</span>) {<br>    <span>// perform login using the provided username and password</span><br>}<br></code></div></div></pre><p>In this example, the <code>getLoginData</code> method returns a two-dimensional array containing two sets of test data. The <code>@DataProvider</code> annotation is used to specify the name of the data provider method. In the test method, we annotate it with the <code>@Test</code> annotation and specify the name of the data provider using the <code>dataProvider</code> attribute. TestNG will automatically run the test method twice, once for each set of test data.</p><p>In conclusion, parameterization is a useful feature in TestNG that allows us to run the same test case with different sets of data. We can use the <code>@Parameters</code> annotation or a data provider method to perform parameterization in our tests.</p></div>"
            },
            {
                "ques": "What are OOPs concepts?",
                "ans": "<div><p>Object-oriented programming (OOP) is a programming paradigm that revolves around objects, which are instances of classes. OOP is designed to represent real-world objects as software entities. In Java, OOPs concepts include:</p><ol><li><p>Abstraction: Abstraction is the process of hiding the internal implementation details of an object and providing only the necessary information to the end-user. It is achieved using interfaces and abstract classes.</p></li><li><p>Encapsulation: Encapsulation is the process of wrapping data and methods into a single unit called a class. This ensures that the data is not directly accessible from outside the class, which protects the data from unwanted modification.</p></li><li><p>Inheritance: Inheritance is the process of creating a new class by inheriting the properties and behaviors of an existing class. The new class is called the derived class or subclass, while the existing class is called the base class or superclass.</p></li><li><p>Polymorphism: Polymorphism is the ability of an object to take on multiple forms. This is achieved through method overloading and method overriding.</p></li><li><p>Association: Association is the relationship between two objects. It is a link between two classes that defines how the two classes are related to each other.</p></li><li><p>Aggregation: Aggregation is a special form of association where an object of one class is a part of another class.</p></li><li><p>Composition: Composition is another form of association where an object of one class is composed of objects of another class.</p></li></ol><p>Example:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Person</span> {<br>    <span>private</span> String name;<br>    <span>private</span> <span>int</span> age;<br><br>    <span><span>public</span> <span>Person</span>(<span>String name, <span>int</span> age</span>)</span> {<br>        <span>this</span>.name = name;<br>        <span>this</span>.age = age;<br>    }<br><br>    <span><span>public</span> String <span>getName</span>()</span> {<br>        <span>return</span> name;<br>    }<br><br>    <span><span>public</span> <span>int</span> <span>getAge</span>()</span> {<br>        <span>return</span> age;<br>    }<br>}<br><br><span>public</span> <span>class</span> <span>Student</span> <span>extends</span> <span>Person</span> {<br>    <span>private</span> <span>int</span> rollNumber;<br><br>    <span><span>public</span> <span>Student</span>(<span>String name, <span>int</span> age, <span>int</span> rollNumber</span>)</span> {<br>        super(name, age);<br>        <span>this</span>.rollNumber = rollNumber;<br>    }<br><br>    <span><span>public</span> <span>int</span> <span>getRollNumber</span>()</span> {<br>        <span>return</span> rollNumber;<br>    }<br>}<br><br><span>public</span> <span>class</span> <span>Main</span> {<br>    <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>        Student student = <span>new</span> Student(<span>\"John\"</span>, <span>20</span>, <span>1234</span>);<br>        System.<span>out</span>.println(<span>\"Name: \"</span> + student.getName());<br>        System.<span>out</span>.println(<span>\"Age: \"</span> + student.getAge());<br>        System.<span>out</span>.println(<span>\"Roll Number: \"</span> + student.getRollNumber());<br>    }<br>}<br></code></div></div></pre><p>In this example, we have a <code>Person</code> class and a <code>Student</code> class that extends the <code>Person</code> class. The <code>Person</code> class has two instance variables: <code>name</code> and <code>age</code>, and the <code>Student</code> class has an additional instance variable called <code>rollNumber</code>. The <code>Student</code> class inherits the <code>getName()</code> and <code>getAge()</code> methods from the <code>Person</code> class, and it also has its own <code>getRollNumber()</code> method. The <code>Main</code> class creates an object of the <code>Student</code> class and prints out the values of its instance variables using its getter methods.</p></div>"
            },
            {
                "ques": "Is Java a pure OOPs programming language?",
                "ans": "<div><p>Java is considered to be an object-oriented programming (OOP) language. It was designed with OOP concepts in mind and provides built-in support for creating and manipulating objects. However, whether Java is a pure OOP language or not is a matter of debate among experts.</p><p>A pure OOP language should have the following characteristics:</p><ol><li><p>Encapsulation - This means that the data and behavior of an object should be hidden from other objects, and can only be accessed through well-defined interfaces.</p></li><li><p>Inheritance - This allows a new class to be based on an existing class, inheriting its attributes and methods.</p></li><li><p>Polymorphism - This allows objects of different types to be treated as if they are of the same type, and enables programming based on interfaces rather than implementation details.</p></li><li><p>Abstraction - This means that the implementation details of an object should be hidden from the user, and only the essential features should be exposed.</p></li></ol><p>Java supports all these concepts, making it a popular choice for developing OOP-based applications. However, some experts argue that Java is not a pure OOP language, as it also supports non-OOP constructs such as primitive data types and static methods.</p><p>Despite this debate, Java remains a widely used language for developing object-oriented applications. Here is an example of how Java supports OOP concepts:</p><pre><div><div><code><span>// Encapsulation example</span><br><span>public</span> <span>class</span> <span>Car</span> {<br>    <span>private</span> String make;<br>    <span>private</span> String model;<br>    <span>private</span> <span>int</span> year;<br>    <br>    <span>// Getter and setter methods for make, model, and year</span><br>    <span>public</span> String <span>getMake</span><span>()</span> {<br>        <span>return</span> make;<br>    }<br>    <br>    <span>public</span> <span>void</span> <span>setMake</span><span>(String make)</span> {<br>        <span>this</span>.make = make;<br>    }<br>    <br>    <span>public</span> String <span>getModel</span><span>()</span> {<br>        <span>return</span> model;<br>    }<br>    <br>    <span>public</span> <span>void</span> <span>setModel</span><span>(String model)</span> {<br>        <span>this</span>.model = model;<br>    }<br>    <br>    <span>public</span> <span>int</span> <span>getYear</span><span>()</span> {<br>        <span>return</span> year;<br>    }<br>    <br>    <span>public</span> <span>void</span> <span>setYear</span><span>(<span>int</span> year)</span> {<br>        <span>this</span>.year = year;<br>    }<br>    <br>    <span>// Method to start the car</span><br>    <span>public</span> <span>void</span> <span>start</span><span>()</span> {<br>        System.out.println(<span>\"Starting \"</span> + make + <span>\" \"</span> + model);<br>    }<br>}<br><br><span>// Inheritance example</span><br><span>public</span> <span>class</span> <span>SportsCar</span> <span>extends</span> <span>Car</span> {<br>    <span>private</span> <span>boolean</span> turbocharged;<br>    <br>    <span>// Getter and setter method for turbocharged</span><br>    <span>public</span> <span>boolean</span> <span>isTurbocharged</span><span>()</span> {<br>        <span>return</span> turbocharged;<br>    }<br>    <br>    <span>public</span> <span>void</span> <span>setTurbocharged</span><span>(<span>boolean</span> turbocharged)</span> {<br>        <span>this</span>.turbocharged = turbocharged;<br>    }<br>    <br>    <span>// Method to display the car's details</span><br>    <span>public</span> <span>void</span> <span>displayDetails</span><span>()</span> {<br>        System.out.println(<span>\"Make: \"</span> + getMake());<br>        System.out.println(<span>\"Model: \"</span> + getModel());<br>        System.out.println(<span>\"Year: \"</span> + getYear());<br>        System.out.println(<span>\"Turbocharged: \"</span> + turbocharged);<br>    }<br>}<br><br><span>// Polymorphism example</span><br><span>public</span> <span>class</span> <span>Vehicle</span> {<br>    <span>public</span> <span>void</span> <span>start</span><span>()</span> {<br>        System.out.println(<span>\"Starting vehicle\"</span>);<br>    }<br>}<br><br><span>public</span> <span>class</span> <span>Car</span> <span>extends</span> <span>Vehicle</span> {<br>    <span>@Override</span><br>    <span>public</span> <span>void</span> <span>start</span><span>()</span> {<br>        System.out.println(<span>\"Starting car\"</span>);<br>    }<br>}<br><br><span>public</span> <span>class</span> <span>Motorcycle</span> <span>extends</span> <span>Vehicle</span> {<br>    <span>@Override</span><br>    <span>public</span> <span>void</span> <span>start</span><span>()</span> {<br>        System.out.println(<span>\"Starting motorcycle\"</span>);<br>    }<br>}<br><br><span>// Abstraction example</span><br><span>public</span> <span>interface</span> <span>Shape</span> {<br>    <span>public</span> <span>double</span> <span>getArea</span><span>()</span>;<br>}<br><br><span>public</span> <span>class</span> <span>Circle</span> <span>implements</span> <span>Shape</span> {<br>    <span>private</span> <span>double</span> radius;<br>    <br>    <span>// Constructor</span><br>    <span>public</span> <span>Circle</span><span>(<span>double</span> radius)</span> {<br>        <span>this</span>.radius = radius;<br>    }<br>    <br>    <span>// Implementation of the getArea method</span><br>    <span>@Override</span><br>    <span>public</span> <span>double</span> <span>getArea</span><span>()</span> {<br>        <span>return</span> Math.PI * radius * radius;<br>    }<br>}<br><br><span>public</span> <span>class</span> <span>Rectangle</span> <span>implements</span> <span>Shape</span> {<br>    <span>private</span> <span>double</span> length;<br>    <span>private</span> <span>double</span> width;<br>    <br>    <span>// Constructor</span><br>    <span>public</span> <span>Rectangle</span><span>(<span>double</span> length, <span>double</span> width)</span> {<br></code></div></div></pre></div>"
            },
            {
                "ques": "What is inheritance and how do we use it in selenium testing framework?",
                "ans": "<div><p>Inheritance is an object-oriented programming concept where a class can inherit properties and behavior from another class. The class that inherits is called the subclass or derived class, and the class it inherits from is called the superclass or base class. Inheritance allows for the reuse of code, promotes code reuse, and can make code easier to read and maintain.</p><p>In Selenium testing framework, inheritance is used to create Page Objects. A Page Object is a design pattern that represents a web page or a section of a web page as an object. It is a way to organize your Selenium code and separate the test code from the page-specific code. Using inheritance, we can create a base Page Object class that contains common elements and methods that are used across multiple web pages. Then, we can create individual Page Objects for each web page, which inherit from the base Page Object class.</p><p>Here is an example:</p><pre><div><div><code><span>public</span> <span>class</span> <span>BasePage</span> {<br>  <span>protected</span> WebDriver driver;<br>  <br>  <span>public</span> <span>BasePage</span><span>(WebDriver driver)</span> {<br>    <span>this</span>.driver = driver;<br>  }<br>  <br>  <span>public</span> WebElement <span>findElement</span><span>(By locator)</span> {<br>    <span>return</span> driver.findElement(locator);<br>  }<br>  <br>  <span>public</span> <span>void</span> <span>click</span><span>(By locator)</span> {<br>    findElement(locator).click();<br>  }<br>}<br><br><span>public</span> <span>class</span> <span>LoginPage</span> <span>extends</span> <span>BasePage</span> {<br>  <span>private</span> <span>By</span> <span>usernameField</span> <span>=</span> By.id(<span>\"username\"</span>);<br>  <span>private</span> <span>By</span> <span>passwordField</span> <span>=</span> By.id(<span>\"password\"</span>);<br>  <span>private</span> <span>By</span> <span>loginButton</span> <span>=</span> By.id(<span>\"login-button\"</span>);<br>  <br>  <span>public</span> <span>LoginPage</span><span>(WebDriver driver)</span> {<br>    <span>super</span>(driver);<br>  }<br>  <br>  <span>public</span> <span>void</span> <span>login</span><span>(String username, String password)</span> {<br>    findElement(usernameField).sendKeys(username);<br>    findElement(passwordField).sendKeys(password);<br>    click(loginButton);<br>  }<br>}<br></code></div></div></pre><p>In the example above, we have a BasePage class that contains the common elements and methods that are used across multiple web pages. The LoginPage class inherits from the BasePage class and contains the elements and methods that are specific to the login page. The LoginPage class uses the findElement() and click() methods from the BasePage class.</p><p>In conclusion, inheritance is a useful object-oriented programming concept that can be used to create reusable code and organize code. In the Selenium testing framework, inheritance is used to create Page Objects, which helps to separate the test code from the page-specific code.</p></div>"
            },
            {
                "ques": "Explain runtime and compile-time polymorphism and how do we use it in selenium testing framework?",
                "ans": "<div><p>Polymorphism is the ability of an object to take on many forms. In Java, there are two types of polymorphism: compile-time polymorphism and runtime polymorphism.</p><p>Compile-time polymorphism, also known as method overloading, allows you to have multiple methods with the same name but with different parameters. The correct method to be called is determined at compile-time based on the number and types of arguments provided. Here's an example of method overloading:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Calculator</span> {<br>    <span>public</span> <span>int</span> <span>add</span><span>(<span>int</span> x, <span>int</span> y)</span> {<br>        <span>return</span> x + y;<br>    }<br>    <span>public</span> <span>double</span> <span>add</span><span>(<span>double</span> x, <span>double</span> y)</span> {<br>        <span>return</span> x + y;<br>    }<br>}<br></code></div></div></pre><p>In this example, the <code>add()</code> method is overloaded to accept both <code>int</code> and <code>double</code> types. The correct method to be called is determined at compile-time based on the argument types. For example, calling <code>add(1, 2)</code> will call the first method, while calling <code>add(1.0, 2.0)</code> will call the second method.</p><p>Runtime polymorphism, also known as method overriding, allows a subclass to provide its own implementation of a method that is already defined in its superclass. The correct method to be called is determined at runtime based on the actual object that the method is called on. Here's an example of method overriding:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Animal</span> {<br>    <span><span>public</span> <span>void</span> <span>makeSound</span>()</span> {<br>        System.<span>out</span>.println(<span>\"The animal makes a sound\"</span>);<br>    }<br>}<br><br><span>public</span> <span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span> {<br>    @Override<br>    <span><span>public</span> <span>void</span> <span>makeSound</span>()</span> {<br>        System.<span>out</span>.println(<span>\"The dog barks\"</span>);<br>    }<br>}<br></code></div></div></pre><p>In this example, the <code>Dog</code> class overrides the <code>makeSound()</code> method from the <code>Animal</code> class with its own implementation. When <code>makeSound()</code> is called on a <code>Dog</code> object, the <code>Dog</code> implementation is called instead of the <code>Animal</code> implementation.</p><p>In Selenium testing framework, we can use both compile-time polymorphism and runtime polymorphism. For example, we can use method overloading to create different methods to perform the same action with different parameters. We can also use method overriding to provide custom implementations of methods in our test classes that inherit from the Selenium classes. This allows us to customize the behavior of the Selenium classes to fit our specific needs.</p></div>"
            },
            {
                "ques": "What is the difference between the list and set?",
                "ans": "<div><p>In Java, <code>List</code> and <code>Set</code> are two of the most commonly used collection interfaces. Although they share some similarities, there are also some significant differences between them.</p><ol><li><p>Definition:<br><code>List</code> is an ordered collection of elements, which allows duplicate elements. <code>Set</code>, on the other hand, is an unordered collection of unique elements.</p></li><li><p>Implementation:<br><code>List</code> is implemented by classes such as <code>ArrayList</code>, <code>LinkedList</code>, and <code>Vector</code>. <code>Set</code> is implemented by classes such as <code>HashSet</code>, <code>TreeSet</code>, and <code>LinkedHashSet</code>.</p></li><li><p>Performance:<br><code>List</code> provides constant-time positional access and is best suited for storing and accessing elements by index. <code>Set</code> doesn't provide any positional access, but provides fast access to individual elements.</p></li><li><p>Ordering:<br><code>List</code> maintains the order of elements as they are added to the list. <code>Set</code> doesn't maintain any order of elements.</p></li><li><p>Duplicates:<br><code>List</code> allows duplicates, which means that the same element can be added multiple times to the list. <code>Set</code> does not allow duplicates, so every element added to the set must be unique.</p></li><li><p>Usage:<br><code>List</code> is commonly used when we want to store an ordered collection of elements, and we need to access the elements by their position. <code>Set</code> is commonly used when we want to store a unique collection of elements and need to check whether a particular element is present in the collection.</p></li></ol><p>In Selenium, we can use <code>List</code> and <code>Set</code> in various scenarios. For example, when we need to retrieve multiple web elements based on a common locator strategy, we can use the <code>findElements</code> method, which returns a <code>List</code> of web elements. On the other hand, when we want to store a unique collection of window handles, we can use a <code>Set</code> to store them without any duplicates.</p></div>"
            },
            {
                "ques": "If we can write only concrete methods, why to declare it as abstract?",
                "ans": "<div><p>In Java, an abstract method is a method that is declared but not implemented in the abstract class. The implementation of the abstract method is left to its subclass. The main reason for declaring a method as abstract is to provide a common interface for all its subclasses to implement, but the implementation may differ based on the subclass's behavior.</p><p>When we declare a class abstract, it means that the class is incomplete and not ready to be instantiated. We declare a class abstract to define a common behavior for all its subclasses to follow, but we do not want to instantiate it. Abstract classes are used as a blueprint for its subclasses, which can extend the abstract class and provide their implementation of the abstract methods.</p><p>One of the primary benefits of using an abstract method is that it provides flexibility in coding, as the implementation of the abstract method is left to the subclass. This allows the developer to create specific implementations of the method based on the subclass's behavior. Additionally, it also ensures that the subclass provides the implementation of the method, which can improve code reliability.</p><p>Here is an example of an abstract class with an abstract method:</p><pre><div><div><code><span>public</span> <span>abstract</span> <span>class</span> <span>Shape</span> {<br>   <span><span>public</span> <span>abstract</span> <span>double</span> <span>area</span>()</span>;<br>}<br></code></div></div></pre><p>The above code defines an abstract class <code>Shape</code> with an abstract method <code>area()</code>. The implementation of the <code>area()</code> method is left to the subclasses of <code>Shape</code>.</p><p>In summary, we use abstract classes and methods in Java to provide a common interface for all its subclasses, ensure implementation of the method by its subclass, and to define an incomplete class that should not be instantiated.</p></div>"
            },
            {
                "ques": "Explain public static void main() {}.",
                "ans": "<div><p>In Java, <code>public static void main()</code> is a special method that serves as the entry point for a Java application. The <code>main()</code> method is the starting point of execution for any Java program and is mandatory for the program to run. The method signature is fixed and follows the format:</p><pre><div><div><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>    <span>// code to be executed</span><br>}<br></code></div></div></pre><p>Let's break down this method signature:</p><ul><li><code>public</code>: Access modifier of the main method.</li><li><code>static</code>: A static method belongs to the class and not to any instance of that class.</li><li><code>void</code>: The <code>main()</code> method does not return any value.</li><li><code>main()</code>: The name of the method.</li><li><code>String[] args</code>: An array of string arguments that can be passed to the main method.</li></ul><p>The <code>main()</code> method is called automatically by the Java Virtual Machine (JVM) when a Java program is executed. It is responsible for initializing the program and calling other methods as needed. The <code>args</code> parameter allows the program to accept input arguments at runtime.</p><p>Here's an example of how to use the <code>main()</code> method in Java:</p><pre><div><div><code><span>public</span> <span>class</span> <span>Main</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>        System.out.println(<span>\"Hello, world!\"</span>);<br>    }<br>}<br></code></div></div></pre><p>In this example, we've created a class called <code>Main</code> with a <code>main()</code> method. When we run the program, the <code>main()</code> method is executed and the text \"Hello, world!\" is printed to the console.</p><p>In summary, the <code>public static void main()</code> method is an essential part of any Java program, serving as the entry point for the program's execution. It takes an array of string arguments and initializes the program, calling other methods as needed.</p></div>"
            },
            {
                "ques": "Can we add a duplicate in a set and map if yes why write one code?",
                "ans": "<div><p>No, a Set and a Map in Java do not allow duplicates. If you try to add a duplicate element to a Set, it will simply ignore the addition and retain the original element. If you try to add a duplicate key to a Map, it will replace the value of the existing key with the new value.</p><p>Let's look at an example to illustrate this:</p><pre><div><div><code>Set&lt;String&gt; <span>set</span> = <span>new</span> HashSet&lt;&gt;();<br><span>set</span>.<span>add</span>(<span>\"apple\"</span>);<br><span>set</span>.<span>add</span>(<span>\"banana\"</span>);<br><span>set</span>.<span>add</span>(<span>\"orange\"</span>);<br><span>set</span>.<span>add</span>(<span>\"apple\"</span>); <span>// adding duplicate element</span><br><br>System.<span>out</span>.println(<span>set</span>);<br></code></div></div></pre><p>In the above code, we are adding four elements to the set, including a duplicate element \"apple\". When we print the set, we will get the output as:</p><pre><div><div><code>[<span>banana, orange, apple</span>]<br></code></div></div></pre><p>Notice that the duplicate element \"apple\" was ignored and only one instance of it was retained in the set.</p><p>Now let's look at an example of adding a duplicate key to a Map:</p><pre><div><div><code>Map&lt;String, Integer&gt; <span>map</span> = <span>new</span> HashMap&lt;&gt;();<br><span>map</span>.put(<span>\"apple\"</span>, <span>1</span>);<br><span>map</span>.put(<span>\"banana\"</span>, <span>2</span>);<br><span>map</span>.put(<span>\"orange\"</span>, <span>3</span>);<br><span>map</span>.put(<span>\"apple\"</span>, <span>4</span>); <span>// adding duplicate key</span><br><br>System.out.<span>println</span>(<span>map</span>);<br></code></div></div></pre><p>In the above code, we are adding four key-value pairs to the map, including a duplicate key \"apple\". When we print the map, we will get the output as:</p><pre><div><div><code>{orange=3, apple=4, banana=2}<br></code></div></div></pre><p>Notice that the value for the key \"apple\" was replaced with the new value of 4, effectively overwriting the previous value of 1.</p><p>In general, it is not a good practice to add duplicates to a Set or Map, as it can lead to unexpected behavior and may violate the intended semantics of these collections.</p></div>"
            },
            {
                "ques": "Difference between Interface and abstract. Can we write only concrete methods in Abstract class?",
                "ans": "<div><p>In Java, both interfaces and abstract classes are used to achieve abstraction, but they differ in their implementation and use.</p><p>An interface in Java is a collection of abstract methods, and all methods defined in an interface are implicitly public and abstract. An interface does not have a constructor, and it can only contain static and final variables. It is used to define a set of rules or contracts that classes implementing the interface must follow. Here is an example of an interface in Java:</p><pre><div><div><code><span>public</span> <span>interface</span> <span>Shape</span> {<br>   <span><span>double</span> <span>area</span>()</span>;<br>}<br></code></div></div></pre><p>On the other hand, an abstract class is a class that cannot be instantiated, and it can contain both concrete and abstract methods. An abstract class can have a constructor, and it can contain instance variables. An abstract class is used as a blueprint for classes that inherit from it. Here is an example of an abstract class in Java:</p><pre><div><div><code><span>public</span> <span>abstract</span> <span>class</span> <span>Shape</span> {<br>   <span><span>public</span> <span>abstract</span> <span>double</span> <span>area</span>()</span>;<br>}<br></code></div></div></pre><p>One of the differences between the two is that a class can implement multiple interfaces, but it can only inherit from one abstract class. Additionally, all methods in an interface are implicitly public, whereas abstract classes can have methods with any access modifier.</p><p>Regarding the second part of the question, it is not necessary to have abstract methods in an abstract class. An abstract class can have concrete methods that are inherited by its subclasses, and the subclasses can override those methods if needed. However, if a class has at least one abstract method, it must be declared abstract. If an abstract class has only concrete methods, it is simply a normal class.</p><p>In summary, both interfaces and abstract classes are used to achieve abstraction in Java, and they differ in their implementation and use. While an interface is a collection of abstract methods, an abstract class is a class that cannot be instantiated, and it can contain both concrete and abstract methods. It is not necessary to have abstract methods in an abstract class, and it can contain only concrete methods if needed.</p></div>"
            },
            {
                "ques": "Difference between hashmap and hash table.",
                "ans": "<div><p>HashMap and HashTable are two implementations of the Map interface in Java that store key-value pairs.</p><p>The main differences between HashMap and HashTable are as follows:</p><ol><li><p>Thread-safety: HashTable is synchronized, while HashMap is not. This means that multiple threads can safely use a HashMap, but a HashTable is accessed exclusively by one thread at a time. Synchronization introduces overhead, which can slow down the performance of HashTable compared to HashMap in single-threaded environments.</p></li><li><p>Null values: HashMap allows null keys and values, while HashTable does not allow null keys or values. If you try to insert a null key or value in a HashTable, it will throw a NullPointerException.</p></li><li><p>Iterator: The iterator returned by HashMap is fail-fast, while the one returned by HashTable is not.</p></li><li><p>Performance: HashMap is generally faster than HashTable, especially for large datasets.</p></li></ol><p>Here is an example that demonstrates the difference between HashMap and HashTable:</p><pre><div><div><code><span>import</span> java.<span>util</span>.<span>HashMap</span>;<br><span>import</span> java.<span>util</span>.<span>Hashtable</span>;<br><span>import</span> java.<span>util</span>.<span>Map</span>;<br><br><span>public</span> <span>class</span> <span>MapExample</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span><span>String</span>[] args</span>) {<br>        <span>Map</span>&lt;<span>Integer</span>, <span>String</span>&gt; hashMap = <span>new</span> <span>HashMap</span>&lt;&gt;();<br>        <span>Map</span>&lt;<span>Integer</span>, <span>String</span>&gt; hashTable = <span>new</span> <span>Hashtable</span>&lt;&gt;();<br><br>        <span>// Adding key-value pairs to both maps</span><br>        hashMap.<span>put</span>(<span>1</span>, <span>\"One\"</span>);<br>        hashMap.<span>put</span>(<span>2</span>, <span>\"Two\"</span>);<br>        hashMap.<span>put</span>(<span>3</span>, <span>\"Three\"</span>);<br><br>        hashTable.<span>put</span>(<span>1</span>, <span>\"One\"</span>);<br>        hashTable.<span>put</span>(<span>2</span>, <span>\"Two\"</span>);<br>        hashTable.<span>put</span>(<span>3</span>, <span>\"Three\"</span>);<br><br>        <span>// Accessing values using keys</span><br>        <span>System</span>.<span>out</span>.<span>println</span>(hashMap.<span>get</span>(<span>1</span>)); <span>// Output: One</span><br>        <span>System</span>.<span>out</span>.<span>println</span>(hashTable.<span>get</span>(<span>1</span>)); <span>// Output: One</span><br><br>        <span>// Adding a null value to the map</span><br>        hashMap.<span>put</span>(<span>4</span>, <span>null</span>);<br>        <span>System</span>.<span>out</span>.<span>println</span>(hashMap.<span>get</span>(<span>4</span>)); <span>// Output: null</span><br><br>        <span>// Adding a null key to the map</span><br>        <span>// This will throw a NullPointerException</span><br>        <span>// hashTable.put(null, \"Null\");</span><br><br>        <span>// Iterating over the map</span><br>        <span>for</span> (<span>Map</span>.<span>Entry</span>&lt;<span>Integer</span>, <span>String</span>&gt; entry : hashMap.<span>entrySet</span>()) {<br>            <span>System</span>.<span>out</span>.<span>println</span>(entry.<span>getKey</span>() + <span>\": \"</span> + entry.<span>getValue</span>());<br>        }<br><br>        <span>// Removing a key-value pair</span><br>        hashMap.<span>remove</span>(<span>3</span>);<br>        <span>System</span>.<span>out</span>.<span>println</span>(hashMap); <span>// Output: {1=One, 2=Two, 4=null}</span><br>    }<br>}<br></code></div></div></pre><p>In this example, we create two maps - one HashMap and one HashTable - and add some key-value pairs to them. We then access the values using their keys, add a null value to the HashMap (which is allowed), and iterate over the HashMap. We also attempt to add a null key to the HashTable, which results in a NullPointerException. Finally, we remove a key-value pair from the HashMap and print out the resulting map.</p></div>"
            },
            {
                "ques": "How to read data from Excel with java? Write sample code.",
                "ans": "<div><p>Reading data from an Excel file is a common task in Java programming, especially in automation testing. Here are the steps to read data from an Excel file in Java:</p><ol><li><p>First, we need to download and add the Apache POI library to the Java project. The POI library provides support for reading and writing data to an Excel file.</p></li><li><p>Once the POI library is added, we need to create an instance of the Workbook interface using the FileInputStream class and the path of the Excel file.</p></li><li><p>Then, we need to get the desired sheet from the workbook using the getSheet() method and get the number of rows in the sheet using the getPhysicalNumberOfRows() method.</p></li><li><p>After that, we need to loop through each row using a for loop and get the number of columns in each row using the getPhysicalNumberOfCells() method.</p></li><li><p>Finally, we can get the value of each cell using the getCell() method and convert it to the desired data type.</p></li></ol><p>Here is a sample code for reading data from an Excel file using Java and Apache POI:</p><pre><div><div><code><span>import</span> java.io.File;<br><span>import</span> java.io.FileInputStream;<br><span>import</span> java.io.IOException;<br><span>import</span> org.apache.poi.ss.usermodel.Cell;<br><span>import</span> org.apache.poi.ss.usermodel.Row;<br><span>import</span> org.apache.poi.ss.usermodel.Sheet;<br><span>import</span> org.apache.poi.ss.usermodel.Workbook;<br><span>import</span> org.apache.poi.xssf.usermodel.XSSFWorkbook;<br><br><span>public</span> <span>class</span> <span>ReadExcelData</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> <span>throws</span> IOException {<br>        <span>String</span> <span>filePath</span> <span>=</span> <span>\"path/to/excel/file.xlsx\"</span>;<br>        <span>FileInputStream</span> <span>inputStream</span> <span>=</span> <span>new</span> <span>FileInputStream</span>(<span>new</span> <span>File</span>(filePath));<br>        <span>Workbook</span> <span>workbook</span> <span>=</span> <span>new</span> <span>XSSFWorkbook</span>(inputStream);<br>        <span>Sheet</span> <span>sheet</span> <span>=</span> workbook.getSheetAt(<span>0</span>);<br>        <span>int</span> <span>rowCount</span> <span>=</span> sheet.getPhysicalNumberOfRows();<br>        <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; i &lt; rowCount; i++) {<br>            <span>Row</span> <span>row</span> <span>=</span> sheet.getRow(i);<br>            <span>int</span> <span>colCount</span> <span>=</span> row.getPhysicalNumberOfCells();<br>            <span>for</span> (<span>int</span> <span>j</span> <span>=</span> <span>0</span>; j &lt; colCount; j++) {<br>                <span>Cell</span> <span>cell</span> <span>=</span> row.getCell(j);<br>                <span>switch</span> (cell.getCellType()) {<br>                    <span>case</span> NUMERIC:<br>                        System.out.print(cell.getNumericCellValue() + <span>\"\\t\"</span>);<br>                        <span>break</span>;<br>                    <span>case</span> STRING:<br>                        System.out.print(cell.getStringCellValue() + <span>\"\\t\"</span>);<br>                        <span>break</span>;<br>                    <span>case</span> BOOLEAN:<br>                        System.out.print(cell.getBooleanCellValue() + <span>\"\\t\"</span>);<br>                        <span>break</span>;<br>                    <span>default</span>:<br>                        System.out.print(<span>\"NA\"</span> + <span>\"\\t\"</span>);<br>                        <span>break</span>;<br>                }<br>            }<br>            System.out.println();<br>        }<br>        workbook.close();<br>        inputStream.close();<br>    }<br>}<br></code></div></div></pre><p>In this example, we are reading the data from the first sheet of an Excel file, which is passed as a parameter to the FileInputStream constructor. We are then looping through each row and cell in the sheet and printing the cell value. The switch statement is used to convert the cell value to the desired data type based on the cell type. Finally, we are closing the workbook and input stream to free up system resources.</p></div>"
            },
            {
                "ques": "What is the difference between FOR and FOR each loop?",
                "ans": "<div><p>In Java, there are two ways to iterate over an array or collection: the <code>for</code> loop and the <code>for each</code> loop. Both loops are used for iteration but have different syntax, usage, and purpose.</p><p>The <code>for</code> loop is a traditional loop that is used when you know the exact number of iterations required. It consists of three parts: initialization, condition, and increment/decrement.</p><p>Example:</p><pre><div><div><code>for (int <span>i</span> = <span>0</span>; <span>i</span> &lt; <span>5</span>; <span>i</span>++) {<br>    System<span>.out</span><span>.println</span>(<span>i</span>);<br>}<br></code></div></div></pre><p>In the example above, the <code>for</code> loop iterates from 0 to 4, printing the values of <code>i</code> in each iteration.</p><p>The <code>for each</code> loop, also known as the enhanced for loop, is used for iterating over collections or arrays. It is simpler to use and provides more readable code.</p><p>Example:</p><pre><div><div><code><span>int</span>[] numbers = {<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>};<br><span>for</span> (<span>int</span> number : numbers) {<br>    System.out.<span>println</span>(number);<br>}<br></code></div></div></pre><p>In the example above, the <code>for each</code> loop iterates over an array of integers <code>numbers</code> and prints each number to the console.</p><p>The main difference between the two loops is that the <code>for</code> loop is used for iterating over a range of values, whereas the <code>for each</code> loop is used for iterating over a collection or array. The <code>for each</code> loop is also more concise and easy to read.</p><p>In Selenium testing, the <code>for each</code> loop can be used for iterating over a collection of web elements, such as links or buttons, to perform some action on each element. For example, to click on every link in a web page, we can use the following code:</p><pre><div><div><code><span>List</span>&lt;<span>WebElement</span>&gt; <span>links</span> = <span>driver</span><span>.findElements</span>(By.<span>tagName</span>(<span>\"a\"</span>));<br><span>for</span> (WebElement <span>link </span>: links) {<br>    <span>link</span><span>.click</span>();<br>}<br></code></div></div></pre><p>This code finds all the links on a web page and iterates over them using a <code>for each</code> loop, clicking on each link.</p></div>"
            },
            {
                "ques": "Which JDK version you are using in your project and why <br>(be careful on that question because indirectly the ask is the advantages of version or latest features added in New version )",
                "ans": "<div><p>As an AI language model, I am not currently working on any specific project and I cannot have preferences on what version of Java to use. However, I can provide some information about the latest JDK version available at the time of this writing.</p><p>The latest version of Java Development Kit (JDK) as of 2023-02-14 is JDK 18, which was released on September 2022. There are several advantages of using the latest version of Java, including the addition of new features and enhancements that can improve the performance, security, and reliability of applications.</p><p>Some of the latest features and enhancements included in JDK 18 are:</p><ul><li>The introduction of Vector API, which provides a set of high-performance operations for math, science, and engineering applications.</li><li>The addition of switch expressions, which allows switch statements to be used as expressions.</li><li>The inclusion of sealed classes and interfaces, which restricts the subtypes that can be defined for a given class or interface.</li><li>The integration of JEP 390, which improves the security of cryptographic operations in Java.</li></ul><p>Using the latest version of Java also ensures that the applications are compatible with the latest technologies and frameworks, and it may provide better support for modern hardware and operating systems.</p><p>However, it is important to consider that upgrading to a new version of Java may require some effort to ensure the application compatibility, and some of the third-party libraries and frameworks used in the project may not yet support the latest version.</p><p>In general, it is recommended to use the latest version of Java, while also considering the requirements and compatibility of the project.</p></div>"
            },
            {
                "ques": "Can we have a Constructor in Abstract class?",
                "ans": "<div><p>Yes, we can have a constructor in an abstract class in Java. A constructor is a special method that is used to initialize an object of a class. It is used to provide initial values to the data members of a class when an object is created. The purpose of the constructor is to ensure that the object is in a valid state.</p><p>When an object is created in Java, the first thing that happens is that the constructor of the class is called. The constructor of an abstract class is called when an object of a concrete subclass is created.</p><p>Here is an example of an abstract class with a constructor:</p><pre><div><div><code><span>abstract</span> <span>class</span> <span>Animal</span> {<br>    <span>protected</span> String name;<br><br>    <span><span>public</span> <span>Animal</span>(<span>String name</span>)</span> {<br>        <span>this</span>.name = name;<br>    }<br><br>    <span><span>public</span> <span>abstract</span> <span>void</span> <span>makeSound</span>()</span>;<br>}<br><br><span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span> {<br>    <span><span>public</span> <span>Dog</span>(<span>String name</span>)</span> {<br>        super(name);<br>    }<br><br>    <span><span>public</span> <span>void</span> <span>makeSound</span>()</span> {<br>        System.<span>out</span>.println(<span>\"Woof!\"</span>);<br>    }<br>}<br><br><span>public</span> <span>class</span> <span>Main</span> {<br>    <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>        Dog dog = <span>new</span> Dog(<span>\"Buddy\"</span>);<br>        System.<span>out</span>.println(<span>\"The dog's name is \"</span> + dog.name);<br>        dog.makeSound();<br>    }<br>}<br></code></div></div></pre><p>In this example, the <code>Animal</code> class is an abstract class that has a constructor that takes a <code>name</code> parameter. The <code>Dog</code> class extends the <code>Animal</code> class and provides an implementation for the <code>makeSound</code> method.</p><p>When we create a <code>Dog</code> object in the <code>main</code> method, the <code>Animal</code> constructor is called first, passing the <code>name</code> parameter \"Buddy\" to it. Then the <code>Dog</code> constructor is called, which calls the <code>Animal</code> constructor using the <code>super</code> keyword, passing the <code>name</code> parameter to it. Finally, we call the <code>makeSound</code> method on the <code>Dog</code> object, which outputs \"Woof!\" to the console.</p></div>"
            },
            {
                "ques": "Can an interface have a concrete class?",
                "ans": "<div><p>No, an interface cannot have a concrete class in Java. An interface is a pure abstraction that defines a set of methods that any implementing class must provide. An interface can only have method signatures and constants, but it cannot have implementations for these methods.</p><p>A concrete class, on the other hand, is a class that can be instantiated, and it provides concrete implementations for all the methods declared in the class. A concrete class can extend an abstract class or implement an interface, and it must provide implementations for all the abstract methods in the superclass or interface.</p><p>However, in Java 8 and later versions, interfaces can have default and static methods with implementations. Default methods are methods that provide a default implementation in the interface itself, and the implementing classes can override them. Static methods are methods that are associated with the interface and not with the implementing classes.</p><p>Here's an example to demonstrate the use of default and static methods in interfaces:</p><pre><div><div><code><span>public</span> <span>interface</span> <span>Vehicle</span> {<br>    <span><span>void</span> <span>start</span>()</span>;<br>    <span><span>void</span> <span>stop</span>()</span>;<br>    <br>    <span><span>default</span> <span>void</span> <span>honk</span>()</span> {<br>        System.<span>out</span>.println(<span>\"Beep beep!\"</span>);<br>    }<br>    <br>    <span><span>static</span> <span>void</span> <span>repair</span>()</span> {<br>        System.<span>out</span>.println(<span>\"Vehicle is being repaired\"</span>);<br>    }<br>}<br><br><span>public</span> <span>class</span> <span>Car</span> <span>implements</span> <span>Vehicle</span> {<br>    @Override<br>    <span><span>public</span> <span>void</span> <span>start</span>()</span> {<br>        System.<span>out</span>.println(<span>\"Car started\"</span>);<br>    }<br>    <br>    @Override<br>    <span><span>public</span> <span>void</span> <span>stop</span>()</span> {<br>        System.<span>out</span>.println(<span>\"Car stopped\"</span>);<br>    }<br>}<br><br><span>public</span> <span>class</span> <span>Main</span> {<br>    <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>        Vehicle car = <span>new</span> Car();<br>        car.start();<br>        car.honk();<br>        Vehicle.repair();<br>    }<br>}<br></code></div></div></pre><p>In this example, the <code>Vehicle</code> interface defines two abstract methods <code>start</code> and <code>stop</code>, a default method <code>honk</code>, and a static method <code>repair</code>. The <code>Car</code> class implements the <code>Vehicle</code> interface and provides implementations for the <code>start</code> and <code>stop</code> methods. The <code>Main</code> class creates an instance of the <code>Car</code> class and invokes the <code>start</code> and <code>honk</code> methods. It also invokes the <code>repair</code> method using the interface name <code>Vehicle</code>.</p></div>"
            },
            {
                "ques": "Final vs finally vs finalize",
                "ans": "<div><p>In Java, final, finally, and finalize are three different concepts used in different contexts.</p><p>Final: It is a keyword used in Java to declare a variable or method or class as unchangeable or constant. A final variable's value cannot be changed after initialization, a final method cannot be overridden by its subclasses, and a final class cannot be extended.</p><p>Example:</p><pre><div><div><code><span>public</span> <span>class</span> <span>FinalExample</span> {<br>  <span>final</span> <span>int</span> <span>x</span> <span>=</span> <span>10</span>;<br>  <span>final</span> <span>String</span> <span>str</span> <span>=</span> <span>\"Hello, World!\"</span>;<br>  <br>  <span>public</span> <span>void</span> <span>display</span><span>()</span> {<br>    System.out.println(x);<br>    System.out.println(str);<br>  }<br>}<br></code></div></div></pre><p>Finally: It is a block that is used to execute a set of statements after the execution of a try-catch block regardless of whether an exception is thrown or not. This block ensures that the resources opened in the try block are closed properly.</p><p>Example:</p><pre><div><div><code>FileWriter file = null;<br>try {<br>  file = new <span>FileWriter</span>(\"example.txt\");<br>  file<span>.write</span>(\"Hello, World!\");<br>} <span>catch</span>(IOException e) {<br>  e<span>.printStackTrace</span>();<br>} finally {<br>  <span>if</span>(file != null) {<br>    try {<br>      file<span>.close</span>();<br>    } <span>catch</span>(IOException e) {<br>      e<span>.printStackTrace</span>();<br>    }<br>  }<br>}<br></code></div></div></pre><p>Finalize: It is a method used to perform cleanup activities before an object is garbage collected by the JVM. The finalize method is called by the garbage collector when it determines that there are no more references to the object.</p><p>Example:</p><pre><div><div><code><span>public</span> <span>class</span> <span>FinalizeExample</span> {<br>  <span>protected</span> <span>void</span> <span>finalize</span><span>()</span> <span>throws</span> Throwable {<br>    System.out.println(<span>\"Object is garbage collected!\"</span>);<br>  }<br><br>  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>    <span>FinalizeExample</span> <span>obj</span> <span>=</span> <span>new</span> <span>FinalizeExample</span>();<br>    obj = <span>null</span>;<br>    System.gc(); <span>// This line will invoke the finalize() method.</span><br>  }<br>}<br></code></div></div></pre><p>In summary, final is used to declare a variable or method or class as unchangeable, finally is used to execute a set of statements after the execution of a try-catch block, and finalize is used to perform cleanup activities before an object is garbage collected.</p></div>"
            },
            {
                "ques": "How do you use Jenkins in your selenium automation project?",
                "ans": "<div><p>Jenkins is a popular open-source automation server that helps in automating software development processes. In the context of Selenium automation projects, Jenkins can be used for continuous integration and continuous delivery (CI/CD) of the test suites. Here's how to use Jenkins in a Selenium automation project:</p><ol><li><p>Install Jenkins: Jenkins can be downloaded from its official website and installed on a local or remote server.</p></li><li><p>Install plugins: After installing Jenkins, install the necessary plugins for Selenium automation such as Selenium plugin, TestNG plugin, and Maven plugin.</p></li><li><p>Create a new job: In Jenkins, create a new job by providing a name, selecting the type of project, and configuring the build steps. In the case of a Selenium automation project, the build steps will include running the test suites.</p></li><li><p>Configure the job: Configure the job by providing the details of the Git repository where the Selenium automation code is hosted, setting the build trigger, and defining the build steps.</p></li><li><p>Run the job: After configuring the job, run it to start the test execution. Jenkins will trigger the test suite, and the results will be displayed in the Jenkins console.</p></li></ol><p>Here's a sample code to run a Selenium test suite in Jenkins using Maven:</p><ol><li>Add the following dependency in the pom.xml file:</li></ol><pre><div><div><code><span><span>&lt;<span>dependency</span>&gt;</span><br>    <span>&lt;<span>groupId</span>&gt;</span>org.seleniumhq.selenium<span>&lt;/<span>groupId</span>&gt;</span><br>    <span>&lt;<span>artifactId</span>&gt;</span>selenium-java<span>&lt;/<span>artifactId</span>&gt;</span><br>    <span>&lt;<span>version</span>&gt;</span>3.141.59<span>&lt;/<span>version</span>&gt;</span><br><span>&lt;/<span>dependency</span>&gt;</span><br></span></code></div></div></pre><ol start=\"2\"><li>Create a new TestNG class:</li></ol><pre><div><div><code><span>public</span> <span>class</span> <span>SampleTest</span> {<br>    <span>WebDriver</span> driver;<br><br>    <span>@BeforeTest</span><br>    <span>public</span> <span>void</span> <span>setup</span>(<span></span>) {<br>        driver = <span>new</span> <span>ChromeDriver</span>();<br>        driver.<span>get</span>(<span>\"https://www.google.com/\"</span>);<br>    }<br><br>    <span>@Test</span><br>    <span>public</span> <span>void</span> <span>searchTest</span>(<span></span>) {<br>        <span>WebElement</span> searchBox = driver.<span>findElement</span>(<span>By</span>.<span>name</span>(<span>\"q\"</span>));<br>        searchBox.<span>sendKeys</span>(<span>\"Selenium automation\"</span>);<br>        searchBox.<span>submit</span>();<br>        <span>Assert</span>.<span>assertTrue</span>(driver.<span>getTitle</span>().<span>contains</span>(<span>\"Selenium automation\"</span>));<br>    }<br><br>    <span>@AfterTest</span><br>    <span>public</span> <span>void</span> <span>tearDown</span>(<span></span>) {<br>        driver.<span>quit</span>();<br>    }<br>}<br></code></div></div></pre><ol start=\"3\"><li>Create a Maven build file and add the following details:</li></ol><pre><div><div><code><span><span>&lt;<span>project</span>&gt;</span><br>  ...<br>  <span>&lt;<span>build</span>&gt;</span><br>    <span>&lt;<span>plugins</span>&gt;</span><br>      <span>&lt;<span>plugin</span>&gt;</span><br>        <span>&lt;<span>groupId</span>&gt;</span>org.apache.maven.plugins<span>&lt;/<span>groupId</span>&gt;</span><br>        <span>&lt;<span>artifactId</span>&gt;</span>maven-compiler-plugin<span>&lt;/<span>artifactId</span>&gt;</span><br>        <span>&lt;<span>version</span>&gt;</span>3.8.0<span>&lt;/<span>version</span>&gt;</span><br>        <span>&lt;<span>configuration</span>&gt;</span><br>          <span>&lt;<span>source</span>&gt;</span>1.8<span>&lt;/<span>source</span>&gt;</span><br>          <span>&lt;<span>target</span>&gt;</span>1.8<span>&lt;/<span>target</span>&gt;</span><br>        <span>&lt;/<span>configuration</span>&gt;</span><br>      <span>&lt;/<span>plugin</span>&gt;</span><br>      <span>&lt;<span>plugin</span>&gt;</span><br>        <span>&lt;<span>groupId</span>&gt;</span>org.apache.maven.plugins<span>&lt;/<span>groupId</span>&gt;</span><br>        <span>&lt;<span>artifactId</span>&gt;</span>maven-surefire-plugin<span>&lt;/<span>artifactId</span>&gt;</span><br>        <span>&lt;<span>version</span>&gt;</span>3.0.0-M3<span>&lt;/<span>version</span>&gt;</span><br>        <span>&lt;<span>configuration</span>&gt;</span><br>          <span>&lt;<span>suiteXmlFiles</span>&gt;</span><br>            <span>&lt;<span>suiteXmlFile</span>&gt;</span>testng.xml<span>&lt;/<span>suiteXmlFile</span>&gt;</span><br>          <span>&lt;/<span>suiteXmlFiles</span>&gt;</span><br>        <span>&lt;/<span>configuration</span>&gt;</span><br>      <span>&lt;/<span>plugin</span>&gt;</span><br>    <span>&lt;/<span>plugins</span>&gt;</span><br>  <span>&lt;/<span>build</span>&gt;</span><br><span>&lt;/<span>project</span>&gt;</span><br></span></code></div></div></pre><ol start=\"4\"><li>Create a Jenkins job and configure it with the details of the Git repository and the Maven build file. Trigger the job to start the test execution.</li></ol><p>In summary, Jenkins can be used to automate the execution of Selenium test suites, thereby saving time and increasing efficiency. It provides a powerful platform for continuous integration and continuous delivery of Selenium tests.</p></div>"
            },
            {
                "ques": "Difference between error and exception in java with example. ",
                "ans": "<div><p>In Java, errors and exceptions are two types of runtime problems that can occur during the execution of a program. Both errors and exceptions are subclasses of the Throwable class, but they serve different purposes.</p><p>An error is a serious problem that occurs at runtime, indicating that the JVM has encountered an issue that it cannot recover from. Examples of errors include OutOfMemoryError, StackOverflowError, and NoClassDefFoundError. These types of errors typically cause the application to terminate.</p><p>On the other hand, an exception is a problem that occurs at runtime but can be handled by the program. Exceptions can occur due to a variety of reasons, such as invalid user input or network connectivity issues. Exceptions are further classified into two categories: checked and unchecked exceptions. Checked exceptions must be handled explicitly, while unchecked exceptions do not have to be handled.</p><p>Here's an example to illustrate the difference between an error and an exception:</p><pre><div><div><code><span>public</span> <span>class</span> <span>ErrorVsExceptionExample</span> {<br>  <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>    <span>// Example of an error</span><br>    <span>int</span>[] arr = <span>new</span> <span>int</span>[Integer.MAX_VALUE];<br><br>    <span>// Example of an exception</span><br>    <span>try</span> {<br>      <span>int</span> result = <span>10</span> / <span>0</span>;<br>    } <span>catch</span> (ArithmeticException e) {<br>      System.<span>out</span>.println(<span>\"Cannot divide by zero\"</span>);<br>    }<br>  }<br>}<br></code></div></div></pre><p>In the example above, we're creating an array with a size that exceeds the maximum integer value. This will result in an OutOfMemoryError, which is an error.</p><p>We're also attempting to divide the integer 10 by 0, which will result in an ArithmeticException, which is an unchecked exception. We've enclosed this code in a try-catch block to handle the exception and print a message to the console.</p><p>In summary, errors and exceptions are both types of runtime problems that can occur in Java programs. Errors are serious problems that typically result in the termination of the application, while exceptions can be handled by the program.</p></div>"
            },
            {
                "ques": "What is the super most class for error and exception in java.",
                "ans": "<div><p>In Java, the <code>Throwable</code> class is the super most class for <code>Error</code> and <code>Exception</code> classes. The <code>Throwable</code> class is at the top of the exception hierarchy in Java, and all exceptions and errors are subclasses of <code>Throwable</code>.</p><p>Both <code>Error</code> and <code>Exception</code> classes are types of <code>Throwable</code>. <code>Error</code> class represents unrecoverable system-level errors, such as <code>OutOfMemoryError</code> and <code>StackOverflowError</code>. <code>Exception</code> class represents exceptional conditions that can be caught and handled by the application, such as <code>IOException</code> and <code>NullPointerException</code>.</p><p>Here's an example code that demonstrates the relationship between <code>Throwable</code>, <code>Error</code> and <code>Exception</code> classes:</p><pre><div><div><code><span>public</span> <span>class</span> <span>ThrowableExample</span> {<br>    <span><span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span>String[] args</span>)</span> {<br>        <span>try</span> {<br>            <span>int</span> a = <span>10</span>/<span>0</span>;<br>        } <span>catch</span>(ArithmeticException e) {<br>            System.<span>out</span>.println(<span>\"Exception occurred: \"</span> + e);<br>        } <span>catch</span>(Throwable t) {<br>            System.<span>out</span>.println(<span>\"Throwable occurred: \"</span> + t);<br>        }<br>    }<br>}<br></code></div></div></pre><p>In the above example, we have used a <code>try-catch</code> block to catch an <code>ArithmeticException</code>, which occurs when we try to divide a number by 0. However, we have also used a <code>catch</code> block for <code>Throwable</code> class, which means any type of <code>Throwable</code> object will be caught by this block.</p><p>When we run the above code, the output will be:</p><pre><div><div><code>Throwable occurred: java.lang.ArithmeticException: / <span>by</span> zero<br></code></div></div></pre><p>This is because the <code>ArithmeticException</code> is a type of <code>Throwable</code>, so it is caught by the <code>catch</code> block for <code>Throwable</code> class. However, the output message mentions <code>ArithmeticException</code> because that was the specific type of <code>Throwable</code> that occurred.</p><p>In summary, <code>Throwable</code> is the super most class for <code>Error</code> and <code>Exception</code> classes, and it represents the top of the Java exception hierarchy.</p></div>"
            },
            {
                "ques": "Why string is immutable in nature?",
                "ans": "<div><p>In Java, a string is an immutable object, which means that once a string object is created, it cannot be modified. Any operation that appears to modify the string actually creates a new string object. This design choice has several benefits, including increased security, improved efficiency, and greater simplicity.</p><p>One major advantage of immutable strings is that they are inherently thread-safe. Because a string cannot be changed after it is created, multiple threads can safely access the same string object without worrying about concurrent modification. This makes strings a popular choice for building concurrent applications in Java.</p><p>Another benefit of immutable strings is that they can be easily shared between different parts of a program. Because a string object cannot be modified, it can be safely passed between different methods or even between different objects without worrying about unwanted changes.</p><p>Finally, immutability makes string operations more efficient. For example, the Java compiler can safely reuse identical string literals in multiple parts of a program, rather than creating a new object each time the string is used.</p><p>Here is an example of how immutability works in Java strings:</p><pre><div><div><code><span>String</span> s1 = <span>\"hello\"</span>;<br><span>String</span> s2 = s1.toUpperCase(); // creates a <span>new</span> <span>string</span> <span>object</span><br>System.out.println(s1); // prints <span>\"hello\"</span><br>System.out.println(s2); // prints <span>\"HELLO\"</span><br></code></div></div></pre><p>In this example, the <code>toUpperCase()</code> method is called on the <code>s1</code> string, which returns a new string object with all the characters in uppercase. The original <code>s1</code> string is not modified, and instead a new string object <code>s2</code> is created with the modified string.</p></div>"
            },
            {
                "ques": "Difference between Access specifier and Access modifier",
                "ans": "<div><p>In Java, access specifiers or access modifiers are used to restrict or grant access to a class, method, or variable from another class. There are four types of access specifiers in Java: public, private, protected, and default (also known as package-private).</p><p>Access specifiers determine the level of access that other classes have to the class, method, or variable. The four types of access specifiers have different levels of visibility, and the accessibility of the class, method, or variable is determined by the access specifier that is used.</p><p>Access modifier is a term used in some other programming languages, which may refer to anything that modifies or changes the accessibility of a class, method, or variable. In Java, however, the term \"access modifier\" is not used, and only \"access specifiers\" are used.</p><p>Here is a brief overview of the four types of access specifiers in Java:</p><ol><li><p>Public: Public access specifier is the least restrictive and grants access to a class, method, or variable from anywhere, even from outside the package.</p></li><li><p>Private: Private access specifier is the most restrictive and grants access to a class, method, or variable only within the same class.</p></li><li><p>Protected: Protected access specifier grants access to a class, method, or variable within the same package or in a subclass, but not to classes in other packages.</p></li><li><p>Default: Default or package-private access specifier grants access to a class, method, or variable within the same package.</p></li></ol><p>Here's an example that illustrates the difference between the access specifiers:</p><pre><div><div><code><span>package</span> com.example;<br><br><span>public</span> <span>class</span> <span>MyClass</span> {<br>    <span>public</span> <span>int</span> publicVar;<br>    <span>private</span> <span>int</span> privateVar;<br>    <span>protected</span> <span>int</span> protectedVar;<br>    <span>int</span> defaultVar;<br>}<br><br><span>public</span> <span>class</span> <span>AnotherClass</span> {<br>    <span>public</span> <span>void</span> <span>accessMethod</span><span>()</span> {<br>        <span>MyClass</span> <span>obj</span> <span>=</span> <span>new</span> <span>MyClass</span>();<br>        obj.publicVar = <span>10</span>;<br>        obj.privateVar = <span>20</span>;    <span>//compile-time error</span><br>        obj.protectedVar = <span>30</span>;<br>        obj.defaultVar = <span>40</span>;<br>    }<br>}<br></code></div></div></pre><p>In the above example, we have a class named MyClass with four variables of different access specifiers. We also have another class named AnotherClass, which attempts to access these variables.</p><p>As you can see, AnotherClass can access the publicVar variable, but not the privateVar variable, which generates a compile-time error. It can also access the protectedVar and defaultVar variables, but only because it's in the same package as MyClass.</p><p>In summary, access specifiers are used to restrict or grant access to a class, method, or variable from another class, whereas access modifier is not a term used in Java and only access specifiers are used.</p></div>"
            },
            {
                "ques": "How to read a .txt file? Write code in java?",
                "ans": "<div><p>In Java, reading a text file can be done using the <code>FileReader</code> and <code>BufferedReader</code> classes. The <code>FileReader</code> class reads the file character by character, and the <code>BufferedReader</code> class reads the file line by line. Here is an example code to read a text file:</p><pre><div><div><code><span>import</span> java.io.BufferedReader;<br><span>import</span> java.io.FileReader;<br><span>import</span> java.io.IOException;<br><br><span>public</span> <span>class</span> <span>ReadTextFile</span> {<br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>        <span>String</span> <span>fileName</span> <span>=</span> <span>\"example.txt\"</span>;<br><br>        <span>try</span> (<span>BufferedReader</span> <span>br</span> <span>=</span> <span>new</span> <span>BufferedReader</span>(<span>new</span> <span>FileReader</span>(fileName))) {<br>            String line;<br>            <span>while</span> ((line = br.readLine()) != <span>null</span>) {<br>                System.out.println(line);<br>            }<br>        } <span>catch</span> (IOException e) {<br>            System.err.format(<span>\"IOException: %s%n\"</span>, e);<br>        }<br>    }<br>}<br></code></div></div></pre><p>In this code, we create a <code>BufferedReader</code> object that reads the text file line by line, and we use a <code>while</code> loop to read each line of the file. The <code>readLine()</code> method returns <code>null</code> when there are no more lines to read. We catch any <code>IOException</code> that might occur.</p><p>Before running this code, make sure that you have a text file named <code>example.txt</code> in the same directory as the Java file.</p><p>This code will print the contents of the text file to the console. You can modify this code to do other things with the text file, such as write its contents to another file, or process the text in some way.</p></div>"
            },
            {
                "ques": "Where do you use multithreading in selenium java automation project?",
                "ans": "<div><p>In a Selenium Java automation project, multithreading can be used in various scenarios to improve the performance and efficiency of the test execution. Some of the scenarios where multithreading can be used are:</p><ol><li><p>Parallel test execution: In a large-scale automation project, there can be hundreds or thousands of test cases to be executed. To reduce the test execution time, the tests can be executed in parallel using multiple threads. TestNG provides the ability to run tests in parallel at the suite, test, class, and method levels.</p></li><li><p>Simulating multiple users: In web application testing, it is often required to simulate multiple users accessing the application at the same time. In this scenario, multithreading can be used to create multiple browser instances, each running in a separate thread, to simulate the concurrent access by multiple users.</p></li><li><p>Handling Ajax calls: In web applications, Ajax calls are used to update a part of the page without reloading the entire page. Ajax calls can be asynchronous, which means the browser can continue to execute other JavaScript code while waiting for the response. In this scenario, multithreading can be used to wait for the response in a separate thread, without blocking the main thread.</p></li></ol><p>Here is an example code snippet that shows how to use multithreading in Selenium Java automation project:</p><pre><div><div><code><span>public</span> <span>class</span> <span>ParallelTest</span> {<br><br>  <span>@Test(threadPoolSize = 3, invocationCount = 10, timeOut = 10000)</span><br>  <span>public</span> <span>void</span> <span>testMethod</span><span>()</span> {<br>    <span>// create a new WebDriver instance</span><br>    <span>WebDriver</span> <span>driver</span> <span>=</span> <span>new</span> <span>ChromeDriver</span>();<br><br>    <span>// navigate to the application URL</span><br>    driver.get(<span>\"https://www.example.com\"</span>);<br><br>    <span>// perform the test steps</span><br>    <span>// ...</span><br><br>    <span>// close the browser</span><br>    driver.quit();<br>  }<br>}<br></code></div></div></pre><p>In this example, the <code>@Test</code> annotation is used to specify that the test method should be executed in a thread pool with a size of 3, for a total of 10 invocations, with a timeout of 10 seconds. Inside the test method, a new <code>WebDriver</code> instance is created and used to perform the test steps. Finally, the browser is closed using the <code>quit()</code> method.</p></div>"
            },
            {
                "ques": "Which type is used in collections to add all the primitive data types?",
                "ans": "<div><p>In Java collections, primitive data types cannot be used directly. Instead, their corresponding wrapper classes are used, which are part of the java.lang package. These wrapper classes are used to convert the primitive data types into objects so that they can be used in collections.</p><p>The eight wrapper classes are:</p><ol><li>Byte</li><li>Short</li><li>Integer</li><li>Long</li><li>Float</li><li>Double</li><li>Character</li><li>Boolean</li></ol><p>These wrapper classes can be used in collections like ArrayList, LinkedList, HashSet, and TreeSet, etc. For example, the following code demonstrates how to add Integer objects to an ArrayList:</p><pre><div><div><code><span>import</span> java.util.ArrayList;<br><br><span>public</span> <span>class</span> <span>CollectionExample</span> {<br>   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br>      ArrayList&lt;Integer&gt; myInts = <span>new</span> <span>ArrayList</span>&lt;Integer&gt;();<br>      myInts.add(<span>1</span>);<br>      myInts.add(<span>2</span>);<br>      myInts.add(<span>3</span>);<br>      myInts.add(<span>4</span>);<br>      System.out.println(myInts);<br>   }<br>}<br></code></div></div></pre><p>In this example, we have created an ArrayList of Integer objects and added four elements to it. The output will be:</p><pre><div><div><code>[<span>1, 2, 3, 4</span>]<br></code></div></div></pre><p>Similarly, the other wrapper classes can be used in collections to store primitive data types.</p></div>"
            },
            {
                "ques": "Why you are using a file buffer reader",
                "ans": "<div><p>In Java, a BufferedReader is used to read text from a character input stream with efficient reading of characters, arrays, and lines. A BufferedReader reads text from a character stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines. This is more efficient than reading a single character at a time, as reading from the underlying stream involves I/O operations that can be slow.</p><p>Here are some reasons why we might choose to use a BufferedReader in Java:</p><ol><li><p>Efficient reading: The BufferedReader is efficient at reading text because it reads data from a character stream in chunks, as opposed to reading one character at a time.</p></li><li><p>Improved performance: By buffering the input, the BufferedReader can reduce the number of reads from the underlying input stream, which can improve performance.</p></li><li><p>Handling large files: When reading large files, buffering can help to prevent memory issues that might occur when attempting to read the entire file into memory at once.</p></li></ol><p>Here is an example of how to use a BufferedReader in Java:</p><pre><div><div><code><span>import</span> java.io.BufferedReader;<br><span>import</span> java.io.FileReader;<br><span>import</span> java.io.IOException;<br><br><span>public</span> <span>class</span> <span>Example</span> {<br><br>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {<br><br>        <span>try</span> (<span>BufferedReader</span> <span>br</span> <span>=</span> <span>new</span> <span>BufferedReader</span>(<span>new</span> <span>FileReader</span>(<span>\"filename.txt\"</span>))) {<br>            String line;<br>            <span>while</span> ((line = br.readLine()) != <span>null</span>) {<br>                System.out.println(line);<br>            }<br>        } <span>catch</span> (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}<br></code></div></div></pre><p>In this example, a BufferedReader is used to read the contents of a file called \"filename.txt\". The while loop reads the file line by line, and the contents of each line are printed to the console using the <code>System.out.println()</code> method. The <code>try-with-resources</code> statement is used to ensure that the BufferedReader is closed when it is no longer needed. This is important because failing to close the BufferedReader can result in resource leaks and other issues.</p></div>"
            },
            {
                "ques": "why main() is declared as static?",
                "ans": "<div><p>In Java, the main() method is the entry point of a program. It is declared as public, static, and void, and it is the first method that is executed when a program is run. The main() method is declared as static for a couple of reasons:</p><ol><li><p>To make it accessible without creating an instance of the class: Since the main() method is the entry point of a program, it needs to be called without creating an object of the class. If the main() method were not declared static, it would be necessary to create an instance of the class before calling the main() method. This would be a waste of resources, especially if the class had a large number of instance variables.</p></li><li><p>To allow it to be called by the JVM: When a program is run, the JVM calls the main() method of the class that is specified on the command line. Since the JVM is not aware of any objects of the class, the main() method must be declared static so that it can be called without creating an object of the class.</p></li></ol><p>Here is an example of a simple program that demonstrates the use of the static main() method:</p><pre><div><div><code><span>public</span> <span>class</span> <span>HelloWorld</span> {<br>   <span>public</span> <span>static</span> <span>void</span> <span>main</span>(<span><span>String</span>[] args</span>) {<br>      <span>System</span>.<span>out</span>.<span>println</span>(<span>\"Hello, world!\"</span>);<br>   }<br>}<br></code></div></div></pre><p>In this example, the main() method is declared as static, which allows it to be called by the JVM without creating an object of the HelloWorld class. When the program is run, the message \"Hello, world!\" is printed to the console.</p></div>"
            }
        ]
    </script>

    <script type="text/javascript">

        const colorList = getRandomColor();

        //Set Random Theme Color from list
        function getRandomColor() {
            const colors = ["#442288", "#4285F4", "#d9a004", "#00963f"];
            const colorsLight = ["#77649e", "#98bbf5", "#e8ce87", "#75d19c"];
            const i = Math.floor(Math.random() * colors.length);
            //return [colors[i], colorsLight[i]];
            return ["#4285F4", "#98bbf5"];
        }

        document.documentElement.style.setProperty("--themeColor", colorList[0]);
        document.documentElement.style.setProperty("--themeColorLight", colorList[1]);

        const quesAnsDiv = `
        
        <div class="question">Q {{INDEX}}: {{QUESTION}}<span class="arrow-down"></span></div>
        <div class="answer">
            <div id="postcontent">
                <div class="code">
                    <code>
                    <b>ANSWER:</b> {{ANSWER}}
                    </code>
                </div>
            </div>
        </div>

        `;


        //Remove undesired elements
        document.addEventListener('DOMContentLoaded', function () {
            //author gadget
            var e = document.querySelector(".about-author");
            if (e) e.remove();

            //breadcrumb
            var e = document.querySelector("#breadcrumb");
            if (e) e.remove();

            //entry-title
            var e = document.querySelector(".entry-title");
            if (e) e.remove();

            //Remove repeatative nav bar
            var e = document.querySelector(".topbar-wrap");
            if (e) e.remove();


            //logo link
            const nodeList = document.querySelectorAll(".logo-img");
            for (let i = 0; i < nodeList.length; i++) {
                nodeList[i].href = 'https://way2qae.blogspot.com/2022/06/home-page.html';
            }


            //Width 95%
            const eleList = document.querySelectorAll(".row-x1");
            for (let i = 0; i < eleList.length; i++) {
                eleList[i].style.width = '95%';
            }

            //view count
            var viewCountElement = document.querySelector("#view-count");
            if (viewCountElement) {
                var visitCount = localStorage.getItem("page_view");
                visitCount = Number(visitCount) + 1;
                if (visitCount < 1500) { visitCount = (1500 + Math.floor((Math.random() * 1000) + 1)); }
                localStorage.setItem("page_view", visitCount);
                for (let i = 1; i <= visitCount; i++) {
                    viewCountElement.innerHTML = visitCount;
                }
            }

            //Add question section
            let number = 1;
            let len = (quesAnsArray.length + "").length;
            quesAnsArray.forEach(qa => {
                let index = number.toString().padStart(len, '0');
                var quesAns = quesAnsDiv.replace('{{QUESTION}}', qa.ques).replace('{{ANSWER}}', qa.ans).replace('{{INDEX}}', index);
                var qaSection = document.querySelector('#qa-section');
                qaSection.innerHTML += quesAns;
                number++;
            });


            //Handle collapsibles
            const questions = document.querySelectorAll(".question");

            questions.forEach(question => {
                question.addEventListener("click", () => {
                    question.scrollIntoView();
                    question.classList.toggle("active");
                    const arrow = question.querySelector(".arrow-down");
                    arrow.classList.toggle("rotate");
                    const answer = question.nextElementSibling;
                    if (answer.style.display === "block") {
                        answer.style.display = "none";
                    } else {
                        answer.style.display = "block";
                    }
                });
            });


            function collapseExpandedQuesAns() {
                const activeQuestions = document.querySelectorAll(".question.active");

                activeQuestions.forEach(activeQues => {
                    activeQues.classList.toggle("active");
                    const activeQuesArrows = activeQues.querySelectorAll(".arrow-down");
                    activeQuesArrows.forEach(activeQuesArrow => {
                        activeQuesArrow.classList.toggle("rotate");
                    });
                    const activeQuesAnswer = activeQues.nextElementSibling;
                    if (activeQuesAnswer.style.display === "block") {
                        activeQuesAnswer.style.display = "none";
                    } else {
                        activeQuesAnswer.style.display = "block";
                    }
                });
            }


        }, false);


    </script>
</body>

</html>